chmod=This function changes the permissions of a list of files.\n\nSyntax:\nchmod LIST
chomp=This function (normally) deletes a trailing newline from the end of a string contained in a variable.\n\nSyntax:\nchomp VARIABLE\nchomp LIST\nchomp
chop=This function chops off the last character of a string variable and returns the character chopped.\n\nSyntax:\nchop VARIABLE\nchop LIST\nchop
chown=This function changes the owner and group of a list of files.\n\nSyntax:\nchown LIST
chr=This function returns the character represented by that NUMBER in the character set.\n\nSyntax:\nchr NUMBER\nchr
chroot=If successful, FILENAME becomes the new root directory for the current process--the starting point for pathnames beginning with "/".\n\nSyntax:\nchroot FILENAME\nchroot
close=This function closes the file, socket, or pipe associated with FILEHANDLE.\n\nSyntax:\nclose FILEHANDLE\nclose
closedir=This function closes a directory opened by opendir and returns the success of that operation.\n\nSyntax:\nclosedir DIRHANDLE
connect=This function initiates a connection with another process that is waiting at an accept.\n\nSyntax:\nconnect SOCKET, NAME
cos=This function returns the cosine of EXPR (expressed in radians).\n\nSyntax:\ncos EXPR\ncos
crypt=This function computes a one-way hash of a string exactly in the manner of crypt(3).\n\nSyntax:\ncrypt PLAINTEXT, SALT
dbmclose=This function breaks the binding between a DBM (database management) file and a hash.\n\nSyntax:\ndbmclose HASH
dbmopen=This binds a DBM file to a hash (that is, an associative array).\n\nSyntax:\ndbmopen HASH, DBNAME, MODE
defined=This function returns a Boolean value saying whether EXPR has a defined value or not.\n\nSyntax:\ndefined EXPR\ndefined
delete=This function deletes an element (or a slice of elements) from the specified hash or array.\n\nSyntax:\ndelete EXPR
die=Outside an eval, this function prints the concatenated value of LIST to STDERR and exits with the current value of $! (the C-library errno variable).\n\nSyntax:\ndie LIST\ndie
do (block)=The doBLOCK form executes the sequence of statements in the BLOCK and returns the value of the last expression evaluated in the block.\n\nSyntax:\ndo BLOCK
do (file)=The doFILE form uses the value of FILE as a filename and executes the contents of the file as a Perl script.\n\nSyntax:\ndo FILE
do (subroutine)=The doSUBROUTINE(LIST) is a deprecated form of a subroutine call.\n\nSyntax:\ndo SUBROUTINE(LIST)
dump=This function causes an immediate core dump.\n\nSyntax:\ndump LABEL\ndump
each=This function steps through a hash one key/value pair at a time.\n\nSyntax:\neach HASH
eof=This function returns true if the next read on FILEHANDLE would return end-of-file, or if FILEHANDLE is not open.\n\nSyntax:\neof FILEHANDLE\neof()\neof
eval=The eval keyword serves two distinct but related purposes in Perl.\n\nSyntax:\neval BLOCK\neval EXPR\neval
exec=The exec function terminates the current program and executes an external command and never returns!!! Use system instead of exec if you want to recover control after the commands exits.\n\nSyntax:\nexec PATHNAME LIST\nexec LIST
exists=This function returns true if the specified hash key or array index exists in its hash or array.\n\nSyntax:\nexists EXPR
exit=This function evaluates EXPR as an integer and exits immediately with that value as the final error status of the program.\n\nSyntax:\nexit EXPR\nexit
exp=This function returns e to the power of EXPR.\n\nSyntax:\nexp EXPR\nexp
fcntl=This function calls your operating system's file control functions, as documented in the fcntl(2) manpage.\n\nSyntax:\nfcntl FILEHANDLE, FUNCTION, SCALAR
fileno=This function returns the file descriptor underlying a filehandle.\n\nSyntax:\nfileno FILEHANDLE
flock=The flock function is Perl's portable file-locking interface, although it locks only entire files, not records.\n\nSyntax:\nflock FILEHANDLE, OPERATION
fork=This function creates two processes out of one by invoking the fork(2) syscall.\n\nSyntax:\nfork
format=This function declares a named sequence of picture lines (with associated values) for use by the write function.\n\nSyntax:\nformat NAME =\n    picture line\n    value list\n    ...\n.
formline=This is an internal function used by formats, although you may also call it yourself.\n\nSyntax:\nformline PICTURE, LIST
getc=This function returns the next byte from the input file attached to FILEHANDLE.\n\nSyntax:\ngetc FILEHANDLE\ngetc
getgrent=These routines iterate through your /etc/group file (or maybe someone else's /etc/group file, if it's coming from a server somewhere).\n\nSyntax:\ngetgrent\nsetgrent\nendgrent
getgrgid=This function looks up a group file entry by group number.\n\nSyntax:\ngetgrgid GID
getgrnam=This function looks up a group file entry by group name.\n\nSyntax:\ngetgrnam NAME
gethostbyaddr=This function translates addresses into names (and alternate addresses).\n\nSyntax:\ngethostbyaddr ADDR, ADDRTYPE
gethostbyname=This function translates a network hostname to its corresponding addresses (and other names).\n\nSyntax:\ngethostbyname NAME
gethostent=These functions iterate through your /etc/hosts file and return each entry one at a time.\n\nSyntax:\ngethostent\nsethostent STAYOPEN\nendhostent
getlogin=This function returns the current login name if found.\n\nSyntax:\ngetlogin
getnetbyaddr=This function translates a network address to the corresponding network name or names.\n\nSyntax:\ngetnetbyaddr ADDR, ADDRTYPE
getnetbyname=This function translates a network name to its corresponding network address.\n\nSyntax:\ngetnetbyname NAME
getnetent=These functions iterate through your /etc/networks file.\n\nSyntax:\ngetnetent\nsetnetent STAYOPEN\nendnetent
getpeername=This function returns the packed socket address of the other end of the SOCKET connection.\n\nSyntax:\ngetpeername SOCKET
getpgrp=This function returns the current process group for the specified PID (use a PID of 0 for the current process).\n\nSyntax:\ngetpgrp PID
getppid=This function returns the process ID of the parent process.\n\nSyntax:\ngetppid
getpriority=This function returns the current priority for a process, a process group, or a user.\n\nSyntax:\ngetpriority WHICH, WHO
getprotobyname=This function translates a protocol name to its corresponding number.\n\nSyntax:\ngetprotobyname NAME
getprotobynumber=This function translates a protocol number to its corresponding name.\n\nSyntax:\ngetprotobynumber NUMBER
getprotoent=These functions iterate through the /etc/protocols file.\n\nSyntax:\ngetprotoent\nsetprotoent STAYOPEN\nendprotoent
getpwnam=This function translates a username to the corresponding /etc/passwd file entry.\n\nSyntax:\ngetpwnam NAME
getpwuid=This function translates a numeric user ID to the corresponding /etc/passwd file entry.\n\nSyntax:\ngetpwuid UID
getservbyname=This function translates a service (port) name to its corresponding port number.\n\nSyntax:\ngetservbyname NAME, PROTO
getservbyport=This function translates a service (port) number to its corresponding names.\n\nSyntax:\ngetservbyport PORT, PROTO
getservent=This function iterates through the /etc/services file or its equivalent.\n\nSyntax:\ngetservent\nsetservent STAYOPEN\nendservent
getsockname=This function returns the packed socket address of this end of the SOCKET connection.\n\nSyntax:\ngetsockname SOCKET
getsockopt=This function returns the socket option requested, or undef if there is an error.\n\nSyntax:\ngetsockopt SOCKET, LEVEL, OPTNAME
glob=This function returns the value of EXPR with filename expansions such as a shell would do.\n\nSyntax:\nglob EXPR\nglob
gmtime=This function converts a time as returned by the time function to a nine-element list with the time correct for the Greenwich time zone (a.\n\nSyntax:\ngmtime EXPR\ngmtime
grep=This function evaluates EXPR or BLOCK in Boolean context for each element of LIST, temporarily setting $_ to each element in turn, much like the foreach construct.\n\nSyntax:\ngrep EXPR, LIST\ngrep BLOCK LIST
hex=This function interprets EXPR as a hexadecimal string and returns the equivalent decimal value.\n\nSyntax:\nhex EXPR\nhex
import=There is no built-in import function.\n\nSyntax:\nimport CLASSNAME LIST\nimport CLASSNAME
index=This function searches for one string within another.\n\nSyntax:\nindex STR, SUBSTR, OFFSET\nindex STR, SUBSTR
int=This function returns the integer portion of EXPR.\n\nSyntax:\nint EXPR\nint
ioctl=This function implements the ioctl(2) syscall which controls I/O.\n\nSyntax:\nioctl FILEHANDLE, FUNCTION, SCALAR
join=This function joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns the string.\n\nSyntax:\njoin EXPR, LIST
keys=This function returns a list consisting of all the keys of the indicated HASH.\n\nSyntax:\nkeys HASH
kill=This function sends a signal to a list of processes.\n\nSyntax:\nkill SIGNAL, LIST
last=The last operator immediately exits the loop in question, just like the break statement in C or Java (as used in loops).\n\nSyntax:\nlast LABEL\nlast
lc=This function returns a lowercased version of EXPR.\n\nSyntax:\nlc EXPR\nlc
lcfirst=This function returns a version of EXPR with the first character lowercased.\n\nSyntax:\nlcfirst EXPR\nlcfirst
length=This function returns the length in characters of the scalar value EXPR.\n\nSyntax:\nlength EXPR\nlength
link=This function creates a new filename linked to the old filename.\n\nSyntax:\nlink OLDFILE, NEWFILE
listen=This function tells the system that you're going to be accepting connections on this SOCKET and that the system can queue the number of waiting connections specified by QUEUESIZE.\n\nSyntax:\nlisten SOCKET, QUEUESIZE
local=This operator does not create a local variable; use my for that.\n\nSyntax:\nlocal EXPR
localtime=This function converts the value returned by time to a nine-element list with the time corrected for the local time zone.\n\nSyntax:\nlocaltime EXPR\nlocaltime
lock=The lock function places a lock on a variable, subroutine, or object referenced by THING until the lock goes out of scope.\n\nSyntax:\nlock THING
log=This function returns the natural logarithm (that is, base e) of EXPR.\n\nSyntax:\nlog EXPR\nlog
m//=This is the match operator, which interprets PATTERN as a regular expression.\n\nSyntax:\n/PATTERN/\nm/PATTERN/
map=This function evaluates the BLOCK or EXPR for each element of LIST (locally setting $_ to each element) and returns the list comprising the results of each such evaluation.\n\nSyntax:\nmap BLOCK LIST\nmap EXPR, LIST
mkdir=This function creates the directory specified by FILENAME, giving it permissions specified by the numeric MASK as modified by the current umask.\n\nSyntax:\nmkdir FILENAME, MASK\nmkdir FILENAME
msgctl=This function calls the System V IPC msgctl(2) syscall; see msgctl(2) for more details.\n\nSyntax:\nmsgctl ID, CMD, ARG
msgget=This function calls the System V IPC msgget(2) syscall.\n\nSyntax:\nmsgget KEY, FLAGS
msgrcv=This function calls the msgrcv(2) syscall to receive a message from message queue ID into variable VAR with a maximum message size of SIZE.\n\nSyntax:\nmsgrcv ID, VAR, SIZE, TYPE, FLAGS
msgsnd=This function calls the msgsnd(2) syscall to send the message MSG to the message queue ID.\n\nSyntax:\nmsgsnd ID, MSG, FLAGS
my=This operator declares one or more private variables to exist only within the innermost enclosing block, subroutine, eval, or file.\n\nSyntax:\nmy TYPE EXPR : ATTRIBUTES\nmy EXPR : ATTRIBUTES\nmy TYPE EXPR\nmy EXPR
new=There is no built-in new function.\n\nSyntax:\nnew CLASSNAME LIST\nnew CLASSNAME
next=The next operator is like the continue statement in C: it starts the next iteration of the loop designated by LABEL: LINE: while (<STDIN>) {    next LINE if /^#/;     # discard comments    .\n\nSyntax:\nnext LABEL\nnext
no=See the use operator, which is the opposite of no, kind of.\n\nSyntax:\nno MODULE LIST
oct=This function interprets EXPR as an octal string and returns the equivalent decimal value.\n\nSyntax:\noct EXPR\noct
open=The open function associates an internal FILEHANDLE with an external file specification given by EXPR or LIST.\n\nSyntax:\nopen FILEHANDLE, MODE, LIST\nopen FILEHANDLE, EXPR\nopen FILEHANDLE
opendir=This function opens a directory named EXPR for processing by readdir, telldir, seekdir, rewinddir, and closedir.\n\nSyntax:\nopendir DIRHANDLE, EXPR
ord=This function returns the numeric value (ASCII, Latin-1, or Unicode) of the first character of EXPR.\n\nSyntax:\nord EXPR\nord
our=An our declares one or more variables to be valid globals within the enclosing block, file, or eval.\n\nSyntax:\nour TYPE EXPR : ATTRIBUTES\nour EXPR : ATTRIBUTES\nour TYPE EXPR\nour EXPR
pack=This function takes a LIST of ordinary Perl values and converts them into a string of bytes according to the TEMPLATE and returns this string.\n\nSyntax:\npack TEMPLATE, LIST
package=This is not really a function, but a declaration that says that the rest of the innermost enclosing scope belongs to the indicated symbol table or namespace.\n\nSyntax:\npackage NAMESPACE\npackage
pipe=Like the corresponding syscall, this function opens a pair of connected pipes--see pipe(2).\n\nSyntax:\npipe READHANDLE, WRITEHANDLE
pop=This function treats an array like a stack--it pops (removes) and returns the last value of the array, shortening the array by one element.\n\nSyntax:\npop ARRAY\npop
pos=This function returns the location in SCALAR where the last m//g search over SCALAR left off.\n\nSyntax:\npos SCALAR\npos
print=This function prints a string or a comma-separated list of strings.\n\nSyntax:\nprint FILEHANDLE LIST\nprint LIST\nprint
printf=This function prints a formatted string to FILEHANDLE or, if omitted, the currently selected output filehandle, initially STDOUT.\n\nSyntax:\nprintf FILEHANDLE FORMAT, LIST\nprintf FORMAT, LIST
prototype=Returns the prototype of a function as a string (or undef if the function has no prototype).\n\nSyntax:\nprototype FUNCTION
push=This function treats ARRAY as a stack and pushes the values of LIST onto the end of ARRAY.\n\nSyntax:\npush ARRAY, LIST
q/STRING/=Generalized quotes.\n\nSyntax:\nq/STRING/\nqq/STRING/\nqr/STRING/\nqw/STRING/\nqx/STRING/
quotemeta=This function returns the value of EXPR with all nonalphanumeric characters backslashed.\n\nSyntax:\nquotemeta EXPR\nquotemeta
rand=This function returns a pseudorandom floating-point number greater than or equal to 0 and less than the value of EXPR.\n\nSyntax:\nrand EXPR\nrand
read      [taintgray]=This function attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE.\n\nSyntax:\nread FILEHANDLE, SCALAR, LENGTH, OFFSET\nread FILEHANDLE, SCALAR, LENGTH
readdir=This function reads directory entries (which are simple filenames) from a directory handle opened by opendir.\n\nSyntax:\nreaddir DIRHANDLE
readline      [taintgray]=This is the internal function implementing the <FILEHANDLE> operator, but you can use it directly.\n\nSyntax:\nreadline FILEHANDLE
readlink=This function returns the filename pointed to by a symbolic link.\n\nSyntax:\nreadlink EXPR\nreadlink
readpipe=This is the internal function implementing the qx// quote construct (also known as the backticks operator).\n\nSyntax:\nreadpipe scalar EXPR\nreadpipe LIST (proposed)
recv      [taintgray]=This function receives a message on a socket.\n\nSyntax:\nrecv SOCKET, SCALAR, LEN, FLAGS
redo=The redo operator restarts a loop block without reevaluating the conditional.\n\nSyntax:\nredo LABEL\nredo
ref=The ref operator returns a true value if EXPR is a reference, false otherwise.\n\nSyntax:\nref EXPR\nref
rename=This function changes the name of a file.\n\nSyntax:\nrename OLDNAME, NEWNAME
require=This function asserts a dependency of some kind on its argument.\n\nSyntax:\nrequire VERSION\nrequire EXPR\nrequire
reset=This function is generally used (or abused) at the top of a loop or in a continue block at the end of a loop, to clear global variables or reset ?? searches so that they work again.\n\nSyntax:\nreset EXPR\nreset
return=This operator causes the current subroutine (or eval or doFILE) to return immediately with the specified value.\n\nSyntax:\nreturn EXPR\nreturn
reverse=In list context, this function returns a list value consisting of the elements of LIST in the opposite order.\n\nSyntax:\nreverse LIST
rewinddir=This function sets the current position to the beginning of the directory for the readdir routine on DIRHANDLE.\n\nSyntax:\nrewinddir DIRHANDLE
rindex=This function works just like index except that it returns the position of the last occurrence of SUBSTR in STR (a reverse index).\n\nSyntax:\nrindex STR, SUBSTR, POSITION\nrindex STR, SUBSTR
rmdir=This function deletes the directory specified by FILENAME if the directory is empty.\n\nSyntax:\nrmdir FILENAME\nrmdir
s///     [taintgray]=The substitution operator.\n\nSyntax:\ns///
scalar=This pseudofunction may be used within a LIST to force EXPR to be evaluated in scalar context when evaluation in the list context would produce a different result.\n\nSyntax:\nscalar EXPR
seek=This function positions the file pointer for FILEHANDLE, just like the fseek(3) call of standard I/O.\n\nSyntax:\nseek FILEHANDLE, OFFSET, WHENCE
seekdir=This function sets the current position for the next call to readdir on DIRHANDLE.\n\nSyntax:\nseekdir DIRHANDLE, POS
select (output filehandle)=For historical reasons, there are two select operators that are totally unrelated to each other.\n\nSyntax:\nselect FILEHANDLE\nselect
select (ready file descriptors)=The four-argument select operator is totally unrelated to the previously described select operator.\n\nSyntax:\nselect RBITS, WBITS, EBITS, TIMEOUT
semctl=This function calls the System V IPC function semctl(2).\n\nSyntax:\nsemctl ID, SEMNUM, CMD, ARG
semget=This function calls the System V IPC syscall semget(2).\n\nSyntax:\nsemget KEY, NSEMS, SIZE, FLAGS
semop=This function calls the System V IPC syscall semop(2) to perform semaphore operations such as signalling and waiting.\n\nSyntax:\nsemop KEY, OPSTRING
send=This function sends a message on a socket.\n\nSyntax:\nsend SOCKET, MSG, FLAGS, TO\nsend SOCKET, MSG, FLAGS
setpgrp=This function sets the current process group (PGRP) for the specified PID (use a PID of 0 for the current process).\n\nSyntax:\nsetpgrp PID, PGRP
setpriority=This function sets the current PRIORITY for a process, a process group, or a user, as specified by the WHICH and WHO.\n\nSyntax:\nsetpriority WHICH, WHO, PRIORITY
setsockopt=This function sets the socket option requested.\n\nSyntax:\nsetsockopt SOCKET, LEVEL, OPTNAME, OPTVAL
shift=This function shifts the first value of the array off and returns it, shortening the array by one and moving everything down.\n\nSyntax:\nshift ARRAY\nshift
shmctl=This function calls the System V IPC syscall, shmctl(2).\n\nSyntax:\nshmctl ID, CMD, ARG
shmget=This function calls the System V IPC syscall, shmget(2).\n\nSyntax:\nshmget KEY, SIZE, FLAGS
shmread=This function reads from the shared memory segment ID starting at position POS for size SIZE (by attaching to it, copying out, and detaching from it).\n\nSyntax:\nshmread ID, VAR, POS, SIZE
shmwrite=This function writes to the shared memory segment ID starting at position POS for size SIZE (by attaching to it, copying in, and detaching from it).\n\nSyntax:\nshmwrite ID, STRING, POS, SIZE
shutdown=This function shuts down a socket connection in the manner indicated by HOW.\n\nSyntax:\nshutdown SOCKET, HOW
sin=Sorry, there's nothing wicked about this operator.\n\nSyntax:\nsin EXPR\nsin
sleep=This function causes the script to sleep for EXPR seconds, or forever if no EXPR, and returns the number of seconds slept.\n\nSyntax:\nsleep EXPR\nsleep
socket=This function opens a socket of the specified kind and attaches it to filehandle SOCKET.\n\nSyntax:\nsocket SOCKET, DOMAIN, TYPE, PROTOCOL
socketpair=This function creates an unnamed pair of sockets in the specified domain, of the specified type.\n\nSyntax:\nsocketpair SOCKET1, SOCKET2, DOMAIN, TYPE, PROTOCOL
sort=This function sorts the LIST and returns the sorted list value.\n\nSyntax:\nsort USERSUB LIST\nsort BLOCK LIST\nsort LIST
splice=This function removes the elements designated by OFFSET and LENGTH from an ARRAY, and replaces them with the elements of LIST, if any.\n\nSyntax:\nsplice ARRAY, OFFSET, LENGTH, LIST\nsplice ARRAY, OFFSET, LENGTH\nsplice ARRAY, OFFSET\nsplice ARRAY
sprintf=This function returns a string formatted by the usual printf conventions of the C library function sprintf.\n\nSyntax:\nsprintf FORMAT, LIST
sqrt=This function returns the square root of EXPR.\n\nSyntax:\nsqrt EXPR\nsqrt
srand=This function sets the random number seed for the rand operator.\n\nSyntax:\nsrand EXPR\nsrand
stat=In scalar context, this function returns a Boolean value that indicates whether the call succeeded.\n\nSyntax:\nstat FILEHANDLE\nstat EXPR\nstat
study=This function takes extra time in order to study SCALAR in anticipation of doing many pattern matches on the string before it is next modified.\n\nSyntax:\nstudy SCALAR\nstudy
substr=This function extracts a substring out of the string given by EXPR and returns it.\n\nSyntax:\nsubstr EXPR, OFFSET, LENGTH, REPLACEMENT\nsubstr EXPR, OFFSET, LENGTH\nsubstr EXPR, OFFSET
symlink=This function creates a new filename symbolically linked to the old filename.\n\nSyntax:\nsymlink OLDNAME, NEWNAME
syscall=This function calls the system call (meaning a syscall, not a shell command) specified as the first element of the list passes the remaining elements as arguments to the system call.\n\nSyntax:\nsyscall LIST
sysopen=The sysopen function opens the file whose filename is given by FILENAME and associates it with FILEHANDLE.\n\nSyntax:\nsysopen FILEHANDLE, FILENAME, MODE, MASK\nsysopen FILEHANDLE, FILENAME, MODE
sysread       [taintgray]=This function attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE using a low-level syscall, read(2).\n\nSyntax:\nsysread FILEHANDLE, SCALAR, LENGTH, OFFSET\nsysread FILEHANDLE, SCALAR, LENGTH
sysseek=This function sets FILEHANDLE's system position using the syscall lseek(2).\n\nSyntax:\nsysseek FILEHANDLE, POSITION, WHENCE
system=This function executes any program on the system for you and returns that program's exit status--not its output.\n\nSyntax:\nsystem PATHNAME LIST\nsystem LIST
syswrite=This function attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE using the write(2) syscall.\n\nSyntax:\nsyswrite FILEHANDLE, SCALAR, LENGTH, OFFSET\nsyswrite FILEHANDLE, SCALAR, LENGTH\nsyswrite FILEHANDLE, SCALAR
tell=This function returns the current file position (in bytes, zero-based) for FILEHANDLE.\n\nSyntax:\ntell FILEHANDLE\ntell
telldir=This function returns the current position of the readdir routines on DIRHANDLE.\n\nSyntax:\ntelldir DIRHANDLE
tie=This function binds a variable to a package class that will provide the implementation for the variable.\n\nSyntax:\ntie VARIABLE, CLASSNAME, LIST
time=This function returns the number of nonleap seconds since "the epoch", traditionally 00:00:00 on January 1st, 1970, UTC.\n\nSyntax:\ntime
times=In list context, this function returns a four-element list giving the user and system CPU times, in seconds (probably fractional), for this process and terminated children of this process.\n\nSyntax:\ntimes
tr///=This is the transliteration (also called translation) operator, which is like the y/// operator in the Unix sed program, only better, in everybody's humble opinion.\n\nSyntax:\ntr///\ny///
truncate=This function truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length.\n\nSyntax:\ntruncate FILEHANDLE, LENGTH\ntruncate EXPR, LENGTH
uc      [taintgray]=This function returns an uppercased version of EXPR.\n\nSyntax:\nuc EXPR\nuc
ucfirst      [taintgray]=This function returns a version of EXPR with the first character capitalized (titlecased in "Unicodese"), and other characters left alone.\n\nSyntax:\nucfirst EXPR\nucfirst
umask=This function sets the umask for the process and returns the old one using the umask(2) syscall.\n\nSyntax:\numask EXPR\numask
undef=Coincidentally, the undef function can also explicitly undefine an entity if you supply its name as an argument.\n\nSyntax:\nundef EXPR\nundef\nundef is the name by which we refer to the abstraction known as "the undefined \nvalue". It also conveniently happens to be the name of a function that always \nreturns the undefined value. We happily confuse the two.
unlink=This function deletes a list of files.\n\nSyntax:\nunlink LIST\nunlink
unpack=This function does the reverse of pack: it expands a string (EXPR) representing a data structure into a list of values according to the TEMPLATE and returns those values.\n\nSyntax:\nunpack TEMPLATE, EXPR
unshift=This function does the opposite of shift.\n\nSyntax:\nunshift ARRAY, LIST
untie=Breaks the binding between the variable or typeglob contained in VARIABLE and the package that it's tied to.\n\nSyntax:\nuntie VARIABLE
use=The use declaration loads in a module, if it hasn't been loaded before, and imports subroutines and variables into the current package from the named module.\n\nSyntax:\nuse MODULE VERSION LIST\nuse MODULE VERSION ()\nuse MODULE VERSION\nuse MODULE LIST\nuse MODULE ()\nuse MODULE\nuse VERSION
utime=This function changes the access and modification times on each file of a list of files.\n\nSyntax:\nutime LIST
values=This function returns a list consisting of all the values in the indicated HASH.\n\nSyntax:\nvalues HASH
vec=The vec function provides compact storage of lists of unsigned integers.\n\nSyntax:\nvec EXPR, OFFSET, BITS
wantarray=This function returns true if the context of the currently executing subroutine is looking for a list value, and false otherwise.\n\nSyntax:\nwantarray
warn=This function produces an error message, printing LIST to STDERR just like die, but doesn't try to exit or throw an exception.\n\nSyntax:\nwarn LIST\nwarn
write=This function writes a formatted record (possibly multiline) to the specified filehandle, using the format associated with that filehandle--see the section "Format Variables" in Chapter 7, "Formats".\n\nSyntax:\nwrite FILEHANDLE\nwrite
y//=The transliteration (historically, also called translation) operator, also known as tr///.\n\nSyntax:\ny///
