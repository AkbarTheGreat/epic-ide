
package org.epic.perleditor.editors;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.FindReplaceDocumentAdapter;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.source.ISourceViewer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.editors.text.TextEditor;
import org.epic.perleditor.PerlEditorPlugin;
import org.epic.perleditor.preferences.ITaskTagConstants;
import org.epic.perleditor.preferences.TaskTagPreferences;

/**
 * @author PTraeder
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class PerlToDoMarkerThread extends Thread implements IdleTimerListener, ITaskTagConstants {
	
	private static final String EPIC_AUTOGENERATED = "epic.autogenerated";
	private final Object lock1 = new Object();
	
	private ISourceViewer fSourceViewer;
	private TextEditor fTextEditor;  
	private String text = null;
	
	public PerlToDoMarkerThread(TextEditor textEditor, ISourceViewer viewer) {
		super();
		this.fTextEditor = textEditor;
		this.fSourceViewer = viewer;
		System.out.println("PerlToDoMarkerThread constructed.");
	}	 
	
	public void onEditorIdle(ISourceViewer viewer) {		
		System.out.println("editor is idle...setting source viewer");
		this.fSourceViewer = viewer;			
		this.setText(fSourceViewer.getDocument().get());
	}  	
	
	public void setText(String newText) {
		synchronized (this.lock1)
		{
			System.out.println("setting text");
			this.text = newText;			
			this.lock1.notifyAll();
		}  	
	}
	
	public void run() {
		try {
			while (!Thread.interrupted()) {
				synchronized (this.lock1) {
					this.lock1.wait();
				}
				
				try {                   
					System.out.println("parsing tasks...");
					IEditorInput input = fTextEditor.getEditorInput();
					IResource resource = (IResource) ((IAdaptable) input).getAdapter(IResource.class);          
					this.parseTasks(resource, text);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		} catch (InterruptedException e) {
			//everything is fine, and this thread will terminate
			System.out.println("PerlToDoMarkerThread has been interrupted...this is normal behaviour and can be ignored.");
		}
	}
	
	private void addTaskMarker(IResource resource, Document document, int start, int stop, int lineNumber, String text) throws BadLocationException {
		Map attributes = new HashMap(11);
		
		AddEditorMarker ed = new AddEditorMarker();
		attributes.put(IMarker.CHAR_START, new Integer(start));
		attributes.put(IMarker.CHAR_END, new Integer(stop));
		
		// get the number of the line in which the current position is
		attributes.put(IMarker.LINE_NUMBER, new Integer(lineNumber));
		
		attributes.put(IMarker.MESSAGE, text);
		attributes.put(EPIC_AUTOGENERATED, new Integer(42));
		
		String markerType = IMarker.TASK;
		
		ed.addMarker(resource, attributes, markerType);  	
	}
	
	public void parseTasks(IResource resource, String sourceCode) {
		
		boolean debug = false;
		
		// load the task tags that we should search for
		IPreferenceStore store = PerlEditorPlugin.getDefault().getPreferenceStore();
		String taskTagList = store.getString(ITaskTagConstants.ID_TASK_TAGS);
		String[] TODO_STRINGS = TaskTagPreferences.parseStringList(taskTagList);
		if (debug)
			System.out.println("loaded " + TODO_STRINGS.length + " task marker strings:");
		
		// delete the old markers
		try {
			IMarker[] markers = resource.findMarkers(IMarker.TASK, true, 1);
			for (int loop = 0; loop < markers.length; loop++) {
				Integer autoGenerated =
					(Integer) markers[loop].getAttribute(EPIC_AUTOGENERATED);
				if (autoGenerated != null) {
					markers[loop].delete();
				}
			}
		} catch (CoreException ce) {
			System.out.println("could not delete the old task markers : ");
			ce.printStackTrace();
		}
		
		// get the source and search for all occurrences of "# TODO"
		Document document = new Document(sourceCode);
		FindReplaceDocumentAdapter findAdapter = new FindReplaceDocumentAdapter(document);
		int totalLineCount = document.getNumberOfLines();
		System.out.println("ignoring case : " + store.getBoolean(ID_IGNORE_CASE));
		
		try {	
			boolean allowWhiteSpace = store.getBoolean(ID_WHITESPACE);
			for (int loop = 0; loop < TODO_STRINGS.length; loop++) {
				// construct the search string
				StringBuffer buffy = new StringBuffer();
				buffy.append("#");
				if (store.getBoolean(ID_WHITESPACE)) {
					buffy.append("\\s*");
				}
				buffy.append(TODO_STRINGS[loop]);
				String currentToDoString = buffy.toString();

				if (debug)
					System.out.println("searching for '" + currentToDoString + "'");
				
				int currentPos = -1;
				
				// TODO for some reason, the ignore case option is being ignored...
				IRegion findResult = findAdapter.find(currentPos + 1, currentToDoString, true, !(store.getBoolean(ID_IGNORE_CASE)), false, true);
				while (findResult != null) {
					currentPos = findResult.getOffset();
										
					if (debug = false)
						System.out.println("found " + currentToDoString	+ " at pos. " + currentPos + ". adding marker.");		
					
					// the start position is the first position after the task tag we found
					int startPos = currentPos + findResult.getLength();
					
					// the stop position is either the first newline after the start position or the end of the document
					int lineNumber = document.getLineOfOffset(currentPos);
					//int lineNumber = document.getNumberOfLines(0, currentPos);
					int stopPos = 0;
					if (lineNumber < totalLineCount) {
						// the last character of this line is two chars before the first char of the next line
						stopPos = document.getLineOffset(lineNumber + 1) - 1;
					}
					else {
						stopPos = document.getLength();						
					}
					if (debug)
						System.out.println("  line " + lineNumber + ", start " + startPos + ", stop " + stopPos);
					String todoText = document.get(startPos, stopPos - startPos).trim();
					
					addTaskMarker(resource, document, currentPos, stopPos, lineNumber+1, todoText);					
					
					findResult = findAdapter.find(currentPos + 1, currentToDoString, true, !(store.getBoolean(ID_IGNORE_CASE)), false, true);
				}
								
			}
		} catch (BadLocationException ble1) {
			ble1.printStackTrace();
		}
	}
	
	public void dispose() throws InterruptedException {
		this.interrupt();
		this.join();
	}
	
}
