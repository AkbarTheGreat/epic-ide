
package org.epic.perleditor.editors;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.source.ISourceViewer;
import org.eclipse.jface.text.source.SourceViewer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.editors.text.TextEditor;

/**
 * @author PTraeder
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class PerlToDoMarkerThread extends Thread implements IdleTimerListener {

  private final Object lock1 = new Object();
  
	private ISourceViewer fSourceViewer;
	private TextEditor fTextEditor;  
	private String text = null;
	
	public PerlToDoMarkerThread(TextEditor textEditor, ISourceViewer viewer) {
		super();
		this.fTextEditor = textEditor;
		this.fSourceViewer = viewer;
		System.out.println("PerlToDoMarkerThread constructed.");
	}	 

  public void onEditorIdle(ISourceViewer viewer) {		
			System.out.println("editor is idle...setting source viewer");
			this.fSourceViewer = viewer;			
			this.setText(fSourceViewer.getTextWidget().getText());  	    		
  }  	
  
  public void setText(String newText) {
		synchronized (this.lock1)
		{
			System.out.println("setting text");
			this.text = newText;			
			this.lock1.notifyAll();
		}  	
  }
    
  public void run() {
    try {
      while (!Thread.interrupted()) {
        synchronized (this.lock1) {
          this.lock1.wait();
        }

        try {                   
          System.out.println("parsing tasks...");
					IEditorInput input = fTextEditor.getEditorInput();
					IResource resource = (IResource) ((IAdaptable) input).getAdapter(IResource.class);          
          this.parseTasks(resource, text);
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    } catch (InterruptedException e) {
      //everything is fine, and this thread will terminate
      System.out.println("PerlToDoMarkerThread has been interrupted...this is normal behaviour and can be ignored.");
    }
  }
  
  public void parseTasks(IResource resource, String sourceCode) {

    // TODO get the strings marking a todo from the configuration
    // at the moment, we´re assuming something like "# TODO text" 
    final String TODO_STRING = "# TODO ";
    final String EPIC_AUTOGENERATED = "epic.autogenerated";

    // delete the old markers
    try {
      IMarker[] markers = resource.findMarkers(IMarker.TASK, true, 1);
      for (int loop = 0; loop < markers.length; loop++) {
        Integer autoGenerated =
          (Integer) markers[loop].getAttribute(EPIC_AUTOGENERATED);
        if (autoGenerated != null) {
          markers[loop].delete();
        }
      }
    } catch (CoreException ce) {
      System.out.println("couldn´t delete the old task markers : ");
      ce.printStackTrace();
    }

    // get the source and search for all occurrences of "# TODO"
    Document document = new Document(sourceCode);
    try {
      int currentPos = -1;
      do {
        currentPos =
          document.search(currentPos + 1, TODO_STRING, true, false, false);

        if (currentPos > -1) {
          System.out.println(
            "found "
              + TODO_STRING
              + " at pos. "
              + currentPos
              + ". adding marker.");

          Map attributes = new HashMap(11);

          AddEditorMarker ed = new AddEditorMarker();
          // the starting char is simple - 
          attributes.put(IMarker.CHAR_START, new Integer(currentPos));
          // the ending char is the first newline after the start position (assuming that each todo ends at the end of the line)
          int stopPos = document.search(currentPos, "\n", true, true, false);
          attributes.put(IMarker.CHAR_END, new Integer(stopPos));

          // get the number of the line in which the current position is
          int lineCountToHere = document.getNumberOfLines(0, currentPos);
          attributes.put(IMarker.LINE_NUMBER, new Integer(lineCountToHere));

          // the text that should be displayed is everything between the end of the TODO marker and the end of the line
          int textStartPos = currentPos + TODO_STRING.length();
          String todoText = document.get(textStartPos, stopPos - textStartPos).trim();          
          attributes.put(IMarker.MESSAGE, todoText);
          // set our own attribute so that we know that this is our marker
          // TODO we should add our own EpicTaskMarker type instead of using attributes
          attributes.put(EPIC_AUTOGENERATED, new Integer(42));

          String markerType = IMarker.TASK;

          ed.addMarker(resource, attributes, markerType);
        }
      } while (currentPos > -1);
    } catch (BadLocationException ble1) {
      ble1.printStackTrace();
    }
  }

}
