
package org.epic.perleditor.editors;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.FindReplaceDocumentAdapter;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.source.ISourceViewer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.editors.text.TextEditor;
import org.epic.perleditor.PerlEditorPlugin;
import org.epic.perleditor.editors.util.MarkerUtil;
import org.epic.perleditor.preferences.ITaskTagConstants;
import org.epic.perleditor.preferences.TaskTagPreferences;

/**
 * @author PTraeder
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class PerlToDoMarkerThread extends Thread implements IdleTimerListener, ITaskTagConstants {
	
	private static final String EPIC_AUTOGENERATED = "epic.autogenerated";
	private final Object lock1 = new Object();
	
	private ISourceViewer fSourceViewer;
	private TextEditor fTextEditor;  
	private String text = null;
	
	private static final boolean debug = false;
	
	public PerlToDoMarkerThread(TextEditor textEditor, ISourceViewer viewer) {
		super("PerlToDoMarkerThread");
		this.fTextEditor = textEditor;
		this.fSourceViewer = viewer;
		debug("PerlToDoMarkerThread constructed.");
	}	 
	
	private void debug(String s) {
		if (debug) {
			System.out.println(s);
		}
	}
	
	public void onEditorIdle(ISourceViewer viewer) {		
		debug("editor is idle...setting source viewer");
		this.fSourceViewer = viewer;			
		this.setText(fSourceViewer.getDocument().get());
	}  	
	
	public void setText(String newText) {
		synchronized (this.lock1)
		{
			debug("setting text");
			this.text = newText;			
			this.lock1.notifyAll();
		}  	
	}
	
	public void run() {
		try {
			while (!Thread.interrupted()) {
				synchronized (this.lock1) {
					this.lock1.wait();
				}
				
				try {                   
					debug("parsing tasks...");
					IEditorInput input = fTextEditor.getEditorInput();
					IResource resource = (IResource) ((IAdaptable) input).getAdapter(IResource.class);          
					this.parseTasks(resource, text);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		} catch (InterruptedException e) {
			//everything is fine, and this thread will terminate
			debug("PerlToDoMarkerThread has been interrupted...this is normal behaviour and can be ignored.");
		}
	}
	
	private void addTaskMarker(MarkerUtil markerUtil, IResource resource, Document document, int start, int stop, int lineNumber, String text) throws BadLocationException {
		Map attributes = new HashMap(11);
		
		attributes.put(IMarker.CHAR_START, new Integer(start));
		attributes.put(IMarker.CHAR_END, new Integer(stop));
		
		// get the number of the line in which the current position is
		attributes.put(IMarker.LINE_NUMBER, new Integer(lineNumber));
		
		attributes.put(IMarker.MESSAGE, text);
		attributes.put(EPIC_AUTOGENERATED, new Integer(42));
		
		String markerType = IMarker.TASK;
		
		markerUtil.addMarker(attributes, markerType);
	}
	
	public void parseTasks(IResource resource, String sourceCode) {
		
		MarkerUtil markerUtil = new MarkerUtil(resource);
		markerUtil.clearAllUsedFlags(IMarker.TASK, EPIC_AUTOGENERATED);
		
		// load the task tags that we should search for
		IPreferenceStore store = PerlEditorPlugin.getDefault().getPreferenceStore();
		String taskTagList = store.getString(ITaskTagConstants.ID_TASK_TAGS);
		String[] TODO_STRINGS = TaskTagPreferences.parseStringList(taskTagList);
		debug("loaded " + TODO_STRINGS.length + " task marker strings:");
			
		// get the source and search for all occurrences of all task tags
		Document document = new Document(sourceCode);
		FindReplaceDocumentAdapter findAdapter = new FindReplaceDocumentAdapter(document);
		int totalLineCount = document.getNumberOfLines();
		debug("ignoring case : " + store.getBoolean(ID_IGNORE_CASE));
		
		try {	
			boolean allowWhiteSpace = store.getBoolean(ID_WHITESPACE);
			for (int loop = 0; loop < TODO_STRINGS.length; loop++) {
				// construct the search string
				StringBuffer buffy = new StringBuffer();
				buffy.append("#");
				if (store.getBoolean(ID_WHITESPACE)) {
					buffy.append("\\s*");
				}
				buffy.append(TODO_STRINGS[loop]);
				String currentToDoString = buffy.toString();

				debug("searching for '" + currentToDoString + "'");
				
				int currentPos = -1;
				
				IRegion findResult = (findAdapter.length() > 0)
                    ? findAdapter.find(
                        currentPos + 1,
                        currentToDoString,
                        true,
                        !(store.getBoolean(ID_IGNORE_CASE)),
                        false,
                        true)
                    : null;

				while (findResult != null) {
					currentPos = findResult.getOffset();
										
					debug("found " + currentToDoString	+ " at pos. " + currentPos + ". adding marker.");		
					
					// the start position is the first position after the task tag we found
					int startPos = currentPos + findResult.getLength();
					
					// the stop position is either the first newline after the start position or the end of the document
					int lineNumber = document.getLineOfOffset(currentPos) + 1;
					debug("current line " + lineNumber + " of " + totalLineCount);
					int stopPos = 0;
					if (lineNumber < totalLineCount) {
						// the last character of this line is one char in front of the first char of the next line
						stopPos = document.getLineOffset(lineNumber) - 1;
						debug("calculating stopPos as last char of line " + lineNumber + " as " + stopPos);
					}
					else {
						stopPos = document.getLength();						
						debug("stopPos is last char of document, in this case " + stopPos);
					}
					debug("  line " + lineNumber + ", start " + startPos + ", stop " + stopPos);
					
					// check if the user has already typed anything behind the task tag
					if (stopPos > startPos) {					
						String todoText = document.get(startPos, stopPos - startPos).trim();
						debug("  text : " + todoText);
						
						if(!markerUtil.isMarkerPresent(IMarker.TASK, lineNumber + 1, todoText, EPIC_AUTOGENERATED, true)) {
							addTaskMarker(markerUtil, resource, document, currentPos, stopPos, lineNumber+1, todoText);
						}
					}
					else {
						debug("ignored empty task tag at line " + lineNumber);
					}
						
					findResult = findAdapter.find(currentPos + 1, currentToDoString, true, !(store.getBoolean(ID_IGNORE_CASE)), false, true);
				}
								
			}
		} catch (BadLocationException ble1) {
			ble1.printStackTrace();
		}
		
		// Remove all unused markers
		markerUtil.removeUnusedMarkers(IMarker.TASK, EPIC_AUTOGENERATED);
	}
	
	public void dispose() throws InterruptedException {
		this.interrupt();
		this.join();
	}
	
}
