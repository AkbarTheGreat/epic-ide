chmod=    chmod LIST\n            Changes the permissions of a list of files. The first\n            element of the list must be the numerical mode, which\n            should probably be an octal number, and which definitely\n            should *not* a string of octal digits: `0644' is okay,\n            `'0644'' is not. Returns the number of files\n            successfully changed. See also the oct entry elsewhere\n            in this document if all you have is a string.\n                chmod 0755, @executables;\n                $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to\n                                                         # --w----r-T\n                $mode = '0644'; chmod oct($mode), 'foo'; # this is better\n                $mode = 0644;   chmod $mode, 'foo';      # this is best\n\n
chomp=    chomp VARIABLE\n    chomp LIST\n    chomp   This safer version of the chop entry elsewhere in this\n            document removes any trailing string that corresponds to\n            the current value of `$/' (also known as\n            $INPUT_RECORD_SEPARATOR in the `English' module). It\n            returns the total number of characters removed from all\n            its arguments. It's often used to remove the newline\n            from the end of an input record when you're worried that\n            the final record may be missing its newline. When in\n            paragraph mode (`$/ = ""'), it removes all trailing\n            newlines from the string. If VARIABLE is omitted, it\n            chomps `$_'. Example:\n                    chomp;  # avoid \\n on last field\n                    @array = split(/:/);\n                    # ...\n                }\n\n            You can actually chomp anything that's an lvalue,\n            including an assignment:\n\n                chomp($cwd = `pwd`);\n                chomp($answer = <STDIN>);\n\n            If you chomp a list, each element is chomped, and the\n            total number of characters removed is returned.\n\n
chop=    chop VARIABLE\n    chop LIST\n    chop    Chops off the last character of a string and returns the\n            character chopped. It's used primarily to remove the\n            newline from the end of an input record, but is much\n            more efficient than `s/\\n//' because it neither scans\n            nor copies the string. If VARIABLE is omitted, chops\n            `$_'. Example:\n                    chop;   # avoid \\n on last field\n                    @array = split(/:/);\n                    #...\n                }\n\n            You can actually chop anything that's an lvalue,\n            including an assignment:\n\n                chop($cwd = `pwd`);\n                chop($answer = <STDIN>);\n\n            If you chop a list, each element is chopped. Only the\n            value of the last `chop()' is returned.\n\n            Note that `chop()' returns the last character. To return\n            all but the last character, use `substr($string, 0, -\n            1)'.\n\n
chown=    chown LIST\n            Changes the owner (and group) of a list of files. The\n            first two elements of the list must be the *NUMERICAL*\n            uid and gid, in that order. Returns the number of files\n            successfully changed.\n                chown $uid, $gid, @filenames;\n\n            Here's an example that looks up nonnumeric uids in the\n            passwd file:\n\n                print "User: ";\n                chop($user = <STDIN>);\n                print "Files: ";\n                chop($pattern = <STDIN>);\n\n                ($login,$pass,$uid,$gid) = getpwnam($user)\n                    or die "$user not in passwd file";\n\n                @ary = glob($pattern);      # expand filenames\n                chown $uid, $gid, @ary;\n\n            On most systems, you are not allowed to change the\n            ownership of the file unless you're the superuser,\n            although you should be able to change the group to any\n            of your secondary groups. On insecure systems, these\n            restrictions may be relaxed, but this is not a portable\n            assumption.\n\n
chr=    chr NUMBER\n    chr     Returns the character represented by that NUMBER in the\n            character set. For example, `chr(65)' is `"A"' in ASCII.\n            For the reverse, use the ord entry elsewhere in this\n            document .\n\n
chroot=    chroot FILENAME\n    chroot  This function works like the system call by the same name:\n            it makes the named directory the new root directory for\n            all further pathnames that begin with a `"/"' by your\n            process and all its children. (It doesn't change your\n            current working directory, which is unaffected.) For\n            security reasons, this call is restricted to the\n            superuser. If FILENAME is omitted, does a `chroot()' to\n            `$_'.
close=    close FILEHANDLE\n    close   Closes the file or pipe associated with the file handle,\n            returning TRUE only if stdio successfully flushes\n            buffers and closes the system file descriptor. Closes\n            the currently selected filehandle if the argument is\n            omitted.\n            immediately going to do another `open()' on it, because\n            `open()' will close it for you. (See `open()'.) However,\n            an explicit `close()' on an input file resets the line\n            counter (`$.'), while the implicit close done by\n            `open()' does not.\n\n            If the file handle came from a piped open `close()' will\n            additionally return FALSE if one of the other system\n            calls involved fails or if the program exits with non-\n            zero status. (If the only problem was that the program\n            exited non-zero `$!' will be set to `0'.) Closing a pipe\n            also waits for the process executing on the pipe to\n            complete, in case you want to look at the output of the\n            pipe afterwards, and implicitly puts the exit status\n            value of that command into `$?'.\n\n            Example:\n\n                open(OUTPUT, '|sort >foo')  # pipe to sort\n                    or die "Can't start sort: $!";\n                #...                        # print stuff to output\n                close OUTPUT                # wait for sort to finish\n                    or warn $! ? "Error closing sort pipe: $!"\n                               : "Exit status $? from sort";\n                open(INPUT, 'foo')          # get sort's results\n                    or die "Can't open 'foo' for input: $!";\n\n            FILEHANDLE may be an expression whose value can be used\n            as an indirect filehandle, usually the real filehandle\n            name.\n\n
closedir=    closedir DIRHANDLE\n            Closes a directory opened by `opendir()' and returns the\n            success of that system call.\n            as an indirect dirhandle, usually the real dirhandle\n            name.\n\n
connect=    connect SOCKET,NAME\n            Attempts to connect to a remote socket, just as the\n            connect system call does. Returns TRUE if it succeeded,\n            FALSE otherwise. NAME should be a packed address of the\n            appropriate type for the socket. See the examples in the\n            section on "Sockets: Client/Server Communication" in the\n            perlipc manpage.
cos=    cos EXPR\n            Returns the cosine of EXPR (expressed in radians). If\n            EXPR is omitted, takes cosine of `$_'.\n            `POSIX::acos()' function, or use this relation:\n\n                sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }\n\n
crypt=    crypt PLAINTEXT,SALT\n            Encrypts a string exactly like the crypt(3) function in\n            the C library (assuming that you actually have a version\n            there that has not been extirpated as a potential\n            munition). This can prove useful for checking the\n            password file for lousy passwords, amongst other things.\n            Only the guys wearing white hats should do this.\n            function, much like breaking eggs to make an omelette.\n            There is no (known) corresponding decrypt function. As a\n            result, this function isn't all that useful for\n            cryptography. (For that, see your nearby CPAN mirror.)\n\n            When verifying an existing encrypted string you should\n            use the encrypted text as the salt (like `crypt($plain,\n            $crypted) eq $crypted'). This allows your code to work\n            with the standard `crypt()' and with more exotic\n            implementations. When choosing a new salt create a\n            random two character string whose characters come from\n            the set `[./0-9A-Za-z]' (like `join '', ('.', '/', 0..9,\n            'A'..'Z', 'a'..'z')[rand 64, rand 64]').\n\n            Here's an example that makes sure that whoever runs this\n            program knows their own password:\n\n                $pwd = (getpwuid($<))[1];\n\n                system "stty -echo";\n                print "Password: ";\n                chomp($word = <STDIN>);\n                print "\\n";\n                system "stty echo";\n\n                if (crypt($word, $pwd) ne $pwd) {\n                    die "Sorry...\\n";\n                } else {\n                    print "ok\\n";\n                }\n\n            Of course, typing in your own password to whoever asks\n            you for it is unwise.\n\n
dbmclose=    dbmclose HASH\n            [This function has been largely superseded by the\n            `untie()' function.]\n\n
dbmopen=    dbmopen HASH,DBNAME,MODE\n            [This function has been largely superseded by the\n            `tie()' function.]\n            Berkeley DB file to a hash. HASH is the name of the\n            hash. (Unlike normal `open()', the first argument is\n            *NOT* a filehandle, even though it looks like one).\n            DBNAME is the name of the database (without the .dir or\n            .pag extension if any). If the database does not exist,\n            it is created with protection specified by MODE (as\n            modified by the `umask()'). If your system supports only\n            the older DBM functions, you may perform only one\n            `dbmopen()' in your program. In older versions of Perl,\n            if your system had neither DBM nor ndbm, calling\n            `dbmopen()' produced a fatal error; it now falls back to\n            sdbm(3).\n\n            If you don't have write access to the DBM file, you can\n            only read hash variables, not set them. If you want to\n            test whether you can write, either use file tests or try\n            setting a dummy hash entry inside an `eval()', which\n            will trap the error.\n\n            Note that functions such as `keys()' and `values()' may\n            return huge lists when used on large DBM files. You may\n            prefer to use the `each()' function to iterate over\n            large DBM files. Example:\n\n                # print out history file offsets\n                dbmopen(%HIST,'/usr/lib/news/history',0666);\n                while (($key,$val) = each %HIST) {\n                    print $key, ' = ', unpack('L',$val), "\\n";\n                }\n                dbmclose(%HIST);\n\n            See also the AnyDBM_File manpage for a more general\n            description of the pros and cons of the various dbm\n            approaches, as well as the DB_File manpage for a\n            particularly rich implementation.\n\n            You can control which DBM library you use by loading\n            that library before you call dbmopen():\n\n                use DB_File;\n                dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")\n                    or die "Can't open netscape history file: $!";\n\n
defined=    defined EXPR\n    defined Returns a Boolean value telling whether EXPR has a value\n            other than the undefined value `undef'. If EXPR is not\n            present, `$_' will be checked.\n            of file, system error, uninitialized variable, and other\n            exceptional conditions. This function allows you to\n            distinguish `undef' from other values. (A simple Boolean\n            test will not distinguish among `undef', zero, the empty\n            string, and `"0"', which are all equally false.) Note\n            that since `undef' is a valid scalar, its presence\n            doesn't *necessarily* indicate an exceptional condition:\n            `pop()' returns `undef' when its argument is an empty\n            array, *or* when the element to return happens to be\n            `undef'.\n\n            You may also use `defined()' to check whether a\n            subroutine exists, by saying `defined &func' without\n            parentheses. On the other hand, use of `defined()' upon\n            aggregates (hashes and arrays) is not guaranteed to\n            produce intuitive results, and should probably be\n            avoided.\n\n            When used on a hash element, it tells you whether the\n            value is defined, not whether the key exists in the\n            hash. Use the exists entry elsewhere in this document\n            for the latter purpose.\n\n            Examples:\n\n                print if defined $switch{'D'};\n                print "$val\\n" while defined($val = pop(@ary));\n                die "Can't readlink $sym: $!"\n                    unless defined($value = readlink $sym);\n                sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }\n                $debugging = 0 unless defined $debugging;\n\n            Note: Many folks tend to overuse `defined()', and then\n            are surprised to discover that the number `0' and `""'\n            (the zero-length string) are, in fact, defined values.\n            For example, if you say\n\n                "ab" =~ /a(.*)b/;\n\n            The pattern match succeeds, and `$1' is defined, despite\n            the fact that it matched "nothing". But it didn't really\n            match nothing--rather, it matched something that\n            happened to be zero characters long. This is all very\n            above-board and honest. When a function returns an\n            undefined value, it's an admission that it couldn't give\n            you an honest answer. So you should use `defined()' only\n            when you're questioning the integrity of what you're\n            trying to do. At other times, a simple comparison to `0'\n            or `""' is what you want.\n\n            Currently, using `defined()' on an entire array or hash\n            reports whether memory for that aggregate has ever been\n            allocated. So an array you set to the empty list appears\n            undefined initially, and one that once was full and that\n            you then set to the empty list still appears defined.\n            You should instead use a simple test for size:\n\n                if (@an_array) { print "has array elements\\n" }\n                if (%a_hash)   { print "has hash members\\n"   }\n\n            Using `undef()' on these, however, does clear their\n            memory and then report them as not defined anymore, but\n            you shouldn't do that unless you don't plan to use them\n            again, because it saves time when you load them up again\n            to have memory already ready to be filled. The normal\n            way to free up space used by an aggregate is to assign\n            the empty list.\n\n            This counterintuitive behavior of `defined()' on\n            aggregates may be changed, fixed, or broken in a future\n            release of Perl.\n\n            See also the undef, exists, and ref entries elsewhere in\n            this document .\n\n
delete=    delete EXPR\n            Deletes the specified key(s) and their associated values\n            from a hash. For each key, returns the deleted value\n            associated with that key, or the undefined value if\n            there was no such key. Deleting from `$ENV{}' modifies\n            the environment. Deleting from a hash tied to a DBM file\n            deletes the entry from the DBM file. (But deleting from\n            a `tie()'d hash doesn't necessarily return anything.)\n\n                foreach $key (keys %HASH) {\n                    delete $HASH{$key};\n                }\n\n            And so does this:\n\n                delete @HASH{keys %HASH}\n\n            But both of these are slower than just assigning the\n            empty list or undefining it:\n\n                %hash = ();         # completely empty %hash\n                undef %hash;        # forget %hash every existed\n\n            Note that the EXPR can be arbitrarily complicated as\n            long as the final operation is a hash element lookup or\n            hash slice:\n\n                delete $ref->[$x][$y]{$key};\n                delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};\n\n
die=    die LIST\n            Outside an `eval()', prints the value of LIST to\n            `STDERR' and exits with the current value of `$!'\n            (errno). If `$!' is `0', exits with the value of `($? >>\n            8)' (backtick `command` status). If `($? >> 8)' is `0',\n            exits with `255'. Inside an `eval(),' the error message\n            is stuffed into `$@' and the `eval()' is terminated with\n            the undefined value. This makes `die()' the way to raise\n            an exception.\n\n                die "Can't cd to spool: $!\\n" unless chdir '/usr/spool/news';\n                chdir '/usr/spool/news' or die "Can't cd to spool: $!\\n"\n\n            If the value of EXPR does not end in a newline, the\n            current script line number and input line number (if\n            any) are also printed, and a newline is supplied. Note\n            that the "input line number" (also known as "chunk") is\n            subject to whatever notion of "line" happens to be\n            currently in effect, and is also available as the\n            special variable `$.'. See the section on "$/" in the\n            perlvar manpage and the section on "$." in the perlvar\n            manpage.\n\n            Hint: sometimes appending `", stopped"' to your message\n            will cause it to make better sense when the string `"at\n            foo line 123"' is appended. Suppose you are running\n            script "canasta".\n\n                die "/etc/games is no good";\n                die "/etc/games is no good, stopped";\n\n            produce, respectively\n\n                /etc/games is no good at canasta line 123.\n                /etc/games is no good, stopped at canasta line 123.\n\n            See also exit(), warn(), and the Carp module.\n\n            If LIST is empty and `$@' already contains a value\n            (typically from a previous eval) that value is reused\n            after appending `"\\t...propagated"'. This is useful for\n            propagating exceptions:\n\n                eval { ... };\n                die unless $@ =~ /Expected exception/;\n\n            If `$@' is empty then the string `"Died"' is used.\n\n            die() can also be called with a reference argument. If\n            this happens to be trapped within an eval(), $@ contains\n            the reference. This behavior permits a more elaborate\n            exception handling implementation using objects that\n            maintain arbitary state about the nature of the\n            exception. Such a scheme is sometimes preferable to\n            matching particular string values of $@ using regular\n            expressions. Here's an example:\n\n                eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };\n                if ($@) {\n                    if (ref($@) && UNIVERSAL::isa($@,"Some::Module::Exception")) {\n                        # handle Some::Module::Exception\n                    }\n                    else {\n                        # handle all other possible exceptions\n                    }\n                }\n\n            Since perl will stringify uncaught exception messages\n            before displaying them, you may want to overload\n            stringification operations on such custom exception\n            objects. See the overload manpage for details about\n            that.\n\n            You can arrange for a callback to be run just before the\n            `die()' does its deed, by setting the `$SIG{__DIE__}'\n            hook. The associated handler will be called with the\n            error text and can change the error message, if it sees\n            fit, by calling `die()' again. See the section on\n            "$SIG{expr}" in the perlvar manpage for details on\n            setting `%SIG' entries, and the section on "eval BLOCK"\n            for some examples.\n\n            Note that the `$SIG{__DIE__}' hook is currently called\n            even inside eval()ed blocks/strings! If one wants the\n            hook to do nothing in such situations, put\n\n                    die @_ if $^S;\n\n            as the first line of the handler (see the section on\n            "$^S" in the perlvar manpage). Because this promotes\n            action at a distance, this counterintuitive behavior may\n            be fixed in a future release.\n\n
do=    do BLOCK\n            Not really a function. Returns the value of the last\n            command in the sequence of commands indicated by BLOCK.\n            When modified by a loop modifier, executes the BLOCK\n            once before testing the loop condition. (On other\n            statements the loop modifiers test the conditional\n            first.)\n            control statements `next', `last', or `redo' cannot be\n            used to leave or restart the block. See the perlsyn\n            manpage for alternative strategies.\n\n    do SUBROUTINE(LIST)\n            A deprecated form of subroutine call. See the perlsub\n            manpage.\n\n    do EXPR Uses the value of EXPR as a filename and executes the\n            contents of the file as a Perl script. Its primary use\n            is to include subroutines from a Perl subroutine\n            library.\n\n                do 'stat.pl';\n\n            is just like\n\n                scalar eval `cat stat.pl`;\n\n            except that it's more efficient and concise, keeps track\n            of the current filename for error messages, searches the\n            @INC libraries, and updates `%INC' if the file is found.\n            See the section on "Predefined Names" in the perlvar\n            manpage for these variables. It also differs in that\n            code evaluated with `do FILENAME' cannot see lexicals in\n            the enclosing scope; `eval STRING' does. It's the same,\n            however, in that it does reparse the file every time you\n            call it, so you probably don't want to do this inside a\n            loop.\n\n            If `do' cannot read the file, it returns undef and sets\n            `$!' to the error. If `do' can read the file but cannot\n            compile it, it returns undef and sets an error message\n            in `$@'. If the file is successfully compiled, `do'\n            returns the value of the last expression evaluated.\n\n            Note that inclusion of library modules is better done\n            with the `use()' and `require()' operators, which also\n            do automatic error checking and raise an exception if\n            there's a problem.\n\n            You might like to use `do' to read in a program\n            configuration file. Manual error checking can be done\n            this way:\n\n                # read in config files: system first, then user \n                for $file ("/share/prog/defaults.rc",\n                           "$ENV{HOME}/.someprogrc") \n               {\n                    unless ($return = do $file) {\n                        warn "couldn't parse $file: $@" if $@;\n                        warn "couldn't do $file: $!"    unless defined $return;\n                        warn "couldn't run $file"       unless $return;\n                    }\n                }\n\n
dump=    dump LABEL\n    dump    This causes an immediate core dump. Primarily this is so\n            that you can use the undump program to turn your core\n            dump into an executable binary after having initialized\n            all your variables at the beginning of the program. When\n            the new binary is executed it will begin by executing a\n            `goto LABEL' (with all the restrictions that `goto'\n            suffers). Think of it as a goto with an intervening core\n            dump and reincarnation. If `LABEL' is omitted, restarts\n            the program from the top. WARNING: Any files opened at\n            the time of the dump will NOT be open any more when the\n            program is reincarnated, with possible resulting\n            confusion on the part of Perl. See also -u option in the\n            perlrun manpage.\n\n                #!/usr/bin/perl\n                require 'getopt.pl';\n                require 'stat.pl';\n                %days = (\n                    'Sun' => 1,\n                    'Mon' => 2,\n                    'Tue' => 3,\n                    'Wed' => 4,\n                    'Thu' => 5,\n                    'Fri' => 6,\n                    'Sat' => 7,\n                );\n\n                dump QUICKSTART if $ARGV[0] eq '-d';\n\n                QUICKSTART:\n                Getopt('f');\n\n            This operator is largely obsolete, partly because it's\n            very hard to convert a core file into an executable, and\n            because the real perl-to-C compiler has superseded it.\n\n
each=    each HASH\n            When called in list context, returns a 2-element list\n            consisting of the key and value for the next element of\n            a hash, so that you can iterate over it. When called in\n            scalar context, returns the key for only the "next"\n            element in the hash. (Note: Keys may be `"0"' or `""',\n            which are logically false; you may wish to avoid\n            constructs like `while ($k = each %foo) {}' for this\n            reason.)\n            actual random order is subject to change in future\n            versions of perl, but it is guaranteed to be in the same\n            order as either the `keys()' or `values()' function\n            would produce on the same (unmodified) hash.\n\n            When the hash is entirely read, a null array is returned\n            in list context (which when assigned produces a FALSE\n            (`0') value), and `undef' in scalar context. The next\n            call to `each()' after that will start iterating again.\n            There is a single iterator for each hash, shared by all\n            `each()', `keys()', and `values()' function calls in the\n            program; it can be reset by reading all the elements\n            from the hash, or by evaluating `keys HASH' or `values\n            HASH'. If you add or delete elements of a hash while\n            you're iterating over it, you may get entries skipped or\n            duplicated, so don't.\n\n            The following prints out your environment like the\n            printenv(1) program, only in a different order:\n\n                while (($key,$value) = each %ENV) {\n                    print "$key=$value\\n";\n                }\n\n            See also `keys()', `values()' and `sort()'.\n\n
eof=    eof FILEHANDLE\n    eof ()\n    eof     Returns 1 if the next read on FILEHANDLE will return end of\n            file, or if FILEHANDLE is not open. FILEHANDLE may be an\n            expression whose value gives the real filehandle. (Note\n            that this function actually reads a character and then\n            `ungetc()'s it, so isn't very useful in an interactive\n            context.) Do not read from a terminal file (or call\n            `eof(FILEHANDLE)' on it) after end-of-file is reached.\n            Filetypes such as terminals may lose the end-of-file\n            condition if you do.\n            argument. Using `eof()' with empty parentheses is very\n            different. It indicates the pseudo file formed of the\n            files listed on the command line, i.e., `eof()' is\n            reasonable to use inside a `while (<>)' loop to detect\n            the end of only the last file. Use `eof(ARGV)' or eof\n            without the parentheses to test *EACH* file in a while\n            (<>) loop. Examples:\n\n                # reset line numbering on each input file\n                while (<>) {\n                    next if /^\\s*#/;        # skip comments \n                    print "$.\\t$_";\n                } continue {\n                    close ARGV  if eof;     # Not eof()!\n                }\n\n                # insert dashes just before last line of last file\n                while (<>) {\n                    if (eof()) {            # check for end of current file\n                        print "--------------\\n";\n                        close(ARGV);        # close or last; is needed if we\n                                            # are reading from the terminal\n                    }\n                    print;\n                }\n\n            Practical hint: you almost never need to use `eof' in\n            Perl, because the input operators return false values\n            when they run out of data, or if there was an error.\n\n
eval=    eval EXPR\n    eval BLOCK\n            In the first form, the return value of EXPR is parsed\n            and executed as if it were a little Perl program. The\n            value of the expression (which is itself determined\n            within scalar context) is first parsed, and if there\n            weren't any errors, executed in the context of the\n            current Perl program, so that any variable settings or\n            subroutine and format definitions remain afterwards.\n            Note that the value is parsed every time the eval\n            executes. If EXPR is omitted, evaluates `$_'. This form\n            is typically used to delay parsing and subsequent\n            execution of the text of EXPR until run time.\n            only once--at the same time the code surrounding the\n            eval itself was parsed--and executed within the context\n            of the current Perl program. This form is typically used\n            to trap exceptions more efficiently than the first (see\n            below), while also providing the benefit of checking the\n            code within BLOCK at compile time.\n\n            The final semicolon, if any, may be omitted from the\n            value of EXPR or within the BLOCK.\n\n            In both forms, the value returned is the value of the\n            last expression evaluated inside the mini-program; a\n            return statement may be also used, just as with\n            subroutines. The expression providing the return value\n            is evaluated in void, scalar, or list context, depending\n            on the context of the eval itself. See the wantarray\n            entry elsewhere in this document for more on how the\n            evaluation context can be determined.\n\n            If there is a syntax error or runtime error, or a\n            `die()' statement is executed, an undefined value is\n            returned by `eval()', and `$@' is set to the error\n            message. If there was no error, `$@' is guaranteed to be\n            a null string. Beware that using `eval()' neither\n            silences perl from printing warnings to STDERR, nor does\n            it stuff the text of warning messages into `$@'. To do\n            either of those, you have to use the `$SIG{__WARN__}'\n            facility. See the warn entry elsewhere in this document\n            the perlvar manpage.\n\n            Note that, because `eval()' traps otherwise-fatal\n            errors, it is useful for determining whether a\n            particular feature (such as `socket()' or `symlink()')\n            is implemented. It is also Perl's exception trapping\n            mechanism, where the die operator is used to raise\n            exceptions.\n\n            If the code to be executed doesn't vary, you may use the\n            eval-BLOCK form to trap run-time errors without\n            incurring the penalty of recompiling each time. The\n            error, if any, is still returned in `$@'. Examples:\n\n                # make divide-by-zero nonfatal\n                eval { $answer = $a / $b; }; warn $@ if $@;\n\n                # same thing, but less efficient\n                eval '$answer = $a / $b'; warn $@ if $@;\n\n                # a compile-time error\n                eval { $answer = };                 # WRONG\n\n                # a run-time error\n                eval '$answer =';   # sets $@\n\n            Due to the current arguably broken state of `__DIE__'\n            hooks, when using the `eval{}' form as an exception trap\n            in libraries, you may wish not to trigger any `__DIE__'\n            hooks that user code may have installed. You can use the\n            `local $SIG{__DIE__}' construct for this purpose, as\n            shown in this example:\n\n                # a very private exception trap for divide-by-zero\n                eval { local $SIG{'__DIE__'}; $answer = $a / $b; };\n                warn $@ if $@;\n\n            This is especially significant, given that `__DIE__'\n            hooks can call `die()' again, which has the effect of\n            changing their error messages:\n\n                # __DIE__ hooks may modify error messages\n                {\n                   local $SIG{'__DIE__'} =\n                          sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };\n                   eval { die "foo lives here" };\n                   print $@ if $@;                # prints "bar lives here"\n                }\n\n            Because this promotes action at a distance, this\n            counterintuive behavior may be fixed in a future\n            release.\n\n            With an `eval()', you should be especially careful to\n            remember what's being looked at when:\n\n                eval $x;            # CASE 1\n                eval "$x";          # CASE 2\n\n                eval '$x';          # CASE 3\n                eval { $x };        # CASE 4\n\n                eval "\\$$x++";      # CASE 5\n                $$x++;              # CASE 6\n\n            Cases 1 and 2 above behave identically: they run the\n            code contained in the variable `$x'. (Although case 2\n            has misleading double quotes making the reader wonder\n            what else might be happening (nothing is).) Cases 3 and\n            4 likewise behave in the same way: they run the code\n            `'$x'', which does nothing but return the value of `$x'.\n            (Case 4 is preferred for purely visual reasons, but it\n            also has the advantage of compiling at compile-time\n            instead of at run-time.) Case 5 is a place where\n            normally you *WOULD* like to use double quotes, except\n            that in this particular situation, you can just use\n            symbolic references instead, as in case 6.\n\n            `eval BLOCK' does *not* count as a loop, so the loop\n            control statements `next', `last', or `redo' cannot be\n            used to leave or restart the block.\n\n
exec=    exec LIST\n    exec PROGRAM LIST\n            The `exec()' function executes a system command *AND\n            NEVER RETURNS* - use `system()' instead of `exec()' if\n            you want it to return. It fails and returns FALSE only\n            if the command does not exist *and* it is executed\n            directly instead of via your system's command shell (see\n            below).\n            `system()', Perl warns you if there is a following\n            statement which isn't `die()', `warn()', or `exit()' (if\n            `-w' is set - but you always do that). If you *really*\n            want to follow an `exec()' with some other statement,\n            you can use one of these styles to avoid the warning:\n\n                exec ('foo')   or print STDERR "couldn't exec foo: $!";\n                { exec ('foo') }; print STDERR "couldn't exec foo: $!";\n\n            If there is more than one argument in LIST, or if LIST\n            is an array with more than one value, calls execvp(3)\n            with the arguments in LIST. If there is only one scalar\n            argument or an array with one element in it, the\n            argument is checked for shell metacharacters, and if\n            there are any, the entire argument is passed to the\n            system's command shell for parsing (this is `/bin/sh -c'\n            on Unix platforms, but varies on other platforms). If\n            there are no shell metacharacters in the argument, it is\n            split into words and passed directly to `execvp()',\n            which is more efficient. Note: `exec()' and `system()'\n            do not flush your output buffer, so you may need to set\n            `$|' to avoid lost output. Examples:\n\n                exec '/bin/echo', 'Your arguments are: ', @ARGV;\n                exec "sort $outfile | uniq";\n\n            If you don't really want to execute the first argument,\n            but want to lie to the program you are executing about\n            its own name, you can specify the program you actually\n            want to run as an "indirect object" (without a comma) in\n            front of the LIST. (This always forces interpretation of\n            the LIST as a multivalued list, even if there is only a\n            single scalar in the list.) Example:\n\n                $shell = '/bin/csh';\n                exec $shell '-sh';          # pretend it's a login shell\n\n            or, more directly,\n\n                exec {'/bin/csh'} '-sh';    # pretend it's a login shell\n\n            When the arguments get executed via the system shell,\n            results will be subject to its quirks and capabilities.\n            See the section on "`STRING`" in the perlop manpage for\n            details.\n\n            Using an indirect object with `exec()' or `system()' is\n            also more secure. This usage forces interpretation of\n            the arguments as a multivalued list, even if the list\n            had just one argument. That way you're safe from the\n            shell expanding wildcards or splitting up words with\n            whitespace in them.\n\n                @args = ( "echo surprise" );\n\n                exec @args;               # subject to shell escapes\n                                            # if @args == 1\n                exec { $args[0] } @args;  # safe even with one-arg list\n\n            The first version, the one without the indirect object,\n            ran the *echo* program, passing it `"surprise"' an\n            argument. The second version didn't--it tried to run a\n            program literally called *"echo surprise"*, didn't find\n            it, and set `$?' to a non-zero value indicating failure.\n\n            Note that `exec()' will not call your `END' blocks, nor\n            will it call any `DESTROY' methods in your objects.\n\n
exists=    exists EXPR\n            Returns TRUE if the specified hash key exists in its\n            hash array, even if the corresponding value is\n            undefined.\n                print "Defined\\n"   if defined $array{$key};\n                print "True\\n"      if $array{$key};\n\n            A hash element can be TRUE only if it's defined, and\n            defined if it exists, but the reverse doesn't\n            necessarily hold true.\n\n            Note that the EXPR can be arbitrarily complicated as\n            long as the final operation is a hash key lookup:\n\n                if (exists $ref->{A}->{B}->{$key})  { }\n                if (exists $hash{A}{B}{$key})       { }\n\n            Although the last element will not spring into existence\n            just because its existence was tested, intervening ones\n            will. Thus `$ref->{"A"}' and `$ref->{"A"}->{"B"}' will\n            spring into existence due to the existence test for a\n            $key element. This happens anywhere the arrow operator\n            is used, including even\n\n                undef $ref;\n                if (exists $ref->{"Some key"})      { }\n                print $ref;             # prints HASH(0x80d3d5c)\n\n            This surprising autovivification in what does not at\n            first--or even second--glance appear to be an lvalue\n            context may be fixed in a future release.\n\n
exit=    exit EXPR\n            Evaluates EXPR and exits immediately with that value.\n            Example:\n                exit 0 if $ans =~ /^[Xx]/;\n\n            See also `die()'. If EXPR is omitted, exits with `0'\n            status. The only universally recognized values for EXPR\n            are `0' for success and `1' for error; other values are\n            subject to interpretation depending on the environment\n            in which the Perl program is running. For example,\n            exiting 69 (EX_UNAVAILABLE) from a *sendmail* incoming-\n            mail filter will cause the mailer to return the item\n            undelivered, but that's not true everywhere.\n\n            Don't use `exit()' to abort a subroutine if there's any\n            chance that someone might want to trap whatever error\n            happened. Use `die()' instead, which can be trapped by\n            an `eval()'.\n\n            The exit() function does not always exit immediately. It\n            calls any defined `END' routines first, but these `END'\n            routines may not themselves abort the exit. Likewise any\n            object destructors that need to be called are called\n            before the real exit. If this is a problem, you can call\n            `POSIX:_exit($status)' to avoid END and destructor\n            processing. See the perlsub manpage for details.\n\n
exp=    exp EXPR\n    exp     Returns *e* (the natural logarithm base) to the power of\n            EXPR. If EXPR is omitted, gives `exp($_)'.
fcntl=    fcntl FILEHANDLE,FUNCTION,SCALAR\n            Implements the fcntl(2) function. You'll probably have\n            to say\n\n            first to get the correct constant definitions. Argument\n            processing and value return works just like `ioctl()'\n            below. For example:\n\n                use Fcntl;\n                fcntl($filehandle, F_GETFL, $packed_return_buffer)\n                    or die "can't fcntl F_GETFL: $!";\n\n            You don't have to check for `defined()' on the return\n            from `fnctl()'. Like `ioctl()', it maps a `0' return\n            from the system call into "`0' but true" in Perl. This\n            string is true in boolean context and `0' in numeric\n            context. It is also exempt from the normal -w warnings\n            on improper numeric conversions.\n\n            Note that `fcntl()' will produce a fatal error if used\n            on a machine that doesn't implement fcntl(2). See the\n            Fcntl module or your fcntl(2) manpage to learn what\n            functions are available on your system.\n\n
fileno=    fileno FILEHANDLE\n            Returns the file descriptor for a filehandle, or\n            undefined if the filehandle is not open. This is mainly\n            useful for constructing bitmaps for `select()' and low-\n            level POSIX tty-handling operations. If FILEHANDLE is an\n            expression, the value is taken as an indirect\n            filehandle, generally its name.\n            to the same underlying descriptor:\n\n                if (fileno(THIS) == fileno(THAT)) {\n                    print "THIS and THAT are dups\\n";\n                } \n\n
flock=    flock FILEHANDLE,OPERATION\n            Calls flock(2), or an emulation of it, on FILEHANDLE.\n            Returns TRUE for success, FALSE on failure. Produces a\n            fatal error if used on a machine that doesn't implement\n            flock(2), fcntl(2) locking, or lockf(3). `flock()' is\n            Perl's portable file locking interface, although it\n            locks only entire files, not records.\n            semantics are that it waits indefinitely until the lock\n            is granted, and that its locks merely advisory. Such\n            discretionary locks are more flexible, but offer fewer\n            guarantees. This means that files locked with `flock()'\n            may be modified by programs that do not also use\n            `flock()'. See the perlport manpage, your port's\n            specific documentation, or your system-specific local\n            manpages for details. It's best to assume traditional\n            behavior if you're writing portable programs. (But if\n            you're not, you should as always feel perfectly free to\n            write for your own system's idiosyncrasies (sometimes\n            called "features"). Slavish adherence to portability\n            concerns shouldn't get in the way of your getting your\n            job done.)\n\n            OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN,\n            possibly combined with LOCK_NB. These constants are\n            traditionally valued 1, 2, 8 and 4, but you can use the\n            symbolic names if import them from the Fcntl module,\n            either individually, or as a group using the ':flock'\n            tag. LOCK_SH requests a shared lock, LOCK_EX requests an\n            exclusive lock, and LOCK_UN releases a previously\n            requested lock. If LOCK_NB is added to LOCK_SH or\n            LOCK_EX then `flock()' will return immediately rather\n            than blocking waiting for the lock (check the return\n            status to see if you got it).\n\n            To avoid the possibility of miscoordination, Perl now\n            flushes FILEHANDLE before locking or unlocking it.\n\n            Note that the emulation built with lockf(3) doesn't\n            provide shared locks, and it requires that FILEHANDLE be\n            open with write intent. These are the semantics that\n            lockf(3) implements. Most if not all systems implement\n            lockf(3) in terms of fcntl(2) locking, though, so the\n            differing semantics shouldn't bite too many people.\n\n            Note also that some versions of `flock()' cannot lock\n            things over the network; you would need to use the more\n            system-specific `fcntl()' for that. If you like you can\n            force Perl to ignore your system's flock(2) function,\n            and so provide its own fcntl(2)-based emulation, by\n            passing the switch `-Ud_flock' to the Configure program\n            when you configure perl.\n\n            Here's a mailbox appender for BSD systems.\n\n                use Fcntl ':flock'; # import LOCK_* constants\n\n                sub lock {\n                    flock(MBOX,LOCK_EX);\n                    # and, in case someone appended\n                    # while we were waiting...\n                    seek(MBOX, 0, 2);\n                }\n\n                sub unlock {\n                    flock(MBOX,LOCK_UN);\n                }\n\n                open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")\n                        or die "Can't open mailbox: $!";\n\n                lock();\n                print MBOX $msg,"\\n\\n";\n                unlock();\n\n            On systems that support a real flock(), locks are\n            inherited across fork() calls, whereas those that must\n            resort to the more capricious fcntl() function lose the\n            locks, making it harder to write servers.\n\n            See also the DB_File manpage for other flock() examples.\n\n
fork=    fork    Does a fork(2) system call to create a new process running\n            the same program at the same point. It returns the child\n            pid to the parent process, `0' to the child process, or\n            `undef' if the fork is unsuccessful. File descriptors\n            (and sometimes locks on those descriptors) are shared,\n            while everything else is copied. On most systems\n            supporting fork(), great care has gone into making it\n            extremely efficient (for example, using copy-on-write\n            technology on data pages), making it the dominant\n            paradigm for multitasking over the last few decades.\n            processes, which means you may need to set `$|'\n            ($AUTOFLUSH in English) or call the `autoflush()' method\n            of `IO::Handle' to avoid duplicate output.\n\n            If you `fork()' without ever waiting on your children,\n            you will accumulate zombies. On some systems, you can\n            avoid this by setting `$SIG{CHLD}' to `"IGNORE"'. See\n            also the perlipc manpage for more examples of forking\n            and reaping moribund children.\n\n            Note that if your forked child inherits system file\n            descriptors like STDIN and STDOUT that are actually\n            connected by a pipe or socket, even if you exit, then\n            the remote server (such as, say, a CGI script or a\n            backgrounded job launced from a remote shell) won't\n            think you're done. You should reopen those to /dev/null\n            if it's any issue.\n\n
format=    format  Declare a picture format for use by the `write()' function.\n            For example:\n                    Test: @<<<<<<<< @||||| @>>>>>\n                          $str,     $%,    '$' . int($num)\n                .\n\n                $str = "widget";\n                $num = $cost/$quantity;\n                $~ = 'Something';\n                write;\n\n            See the perlform manpage for many details and examples.\n\n
formline=    formline PICTURE,LIST\n            This is an internal function used by `format's, though\n            you may call it, too. It formats (see the perlform\n            manpage) a list of values according to the contents of\n            PICTURE, placing the output into the format output\n            accumulator, `$^A' (or `$ACCUMULATOR' in English).\n            Eventually, when a `write()' is done, the contents of\n            `$^A' are written to some filehandle, but you could also\n            read `$^A' yourself and then set `$^A' back to `""'.\n            Note that a format typically does one `formline()' per\n            line of form, but the `formline()' function itself\n            doesn't care how many newlines are embedded in the\n            PICTURE. This means that the `~' and `~~' tokens will\n            treat the entire PICTURE as a single line. You may\n            therefore need to use multiple formlines to implement a\n            single record format, just like the format compiler.\n            because an "`@'" character may be taken to mean the\n            beginning of an array name. `formline()' always returns\n            TRUE. See the perlform manpage for other examples.\n\n
getc=    getc FILEHANDLE\n    getc    Returns the next character from the input file attached to\n            FILEHANDLE, or the undefined value at end of file, or if\n            there was an error. If FILEHANDLE is omitted, reads from\n            STDIN. This is not particularly efficient. However, it\n            cannot be used by itself to fetch single characters\n            without waiting for the user to hit enter. For that, try\n            something more like:\n                    system "stty cbreak </dev/tty >/dev/tty 2>&1";\n                }\n                else {\n                    system "stty", '-icanon', 'eol', "\\001";\n                }\n\n                $key = getc(STDIN);\n\n                if ($BSD_STYLE) {\n                    system "stty -cbreak </dev/tty >/dev/tty 2>&1";\n                }\n                else {\n                    system "stty", 'icanon', 'eol', '^@'; # ASCII null\n                }\n                print "\\n";\n\n            Determination of whether $BSD_STYLE should be set is\n            left as an exercise to the reader.\n\n            The `POSIX::getattr()' function can do this more\n            portably on systems purporting POSIX compliance. See\n            also the `Term::ReadKey' module from your nearest CPAN\n            site; details on CPAN can be found on the "CPAN" entry\n            in the perlmodlib manpage.\n\n
getgrent=    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getgrgid=    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getgrnam=    getgrnam NAME\n    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
gethostbyaddr=    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
gethostbyname=    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
gethostent=    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getlogin=    getlogin\n            Implements the C library function of the same name,\n            which on most systems returns the current login from\n            /etc/utmp, if any. If null, use `getpwuid()'.\n\n            Do not consider `getlogin()' for authentication: it is\n            not as secure as `getpwuid()'.\n\n
getnetbyaddr=    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getnetbyname=    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getnetent=    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getpeername=    getpeername SOCKET\n            Returns the packed sockaddr address of other end of the\n            SOCKET connection.\n                $hersockaddr    = getpeername(SOCK);\n                ($port, $iaddr) = unpack_sockaddr_in($hersockaddr);\n                $herhostname    = gethostbyaddr($iaddr, AF_INET);\n                $herstraddr     = inet_ntoa($iaddr);\n\n
getpgrp=    getpgrp PID\n            Returns the current process group for the specified PID.\n            Use a PID of `0' to get the current process group for\n            the current process. Will raise an exception if used on\n            a machine that doesn't implement getpgrp(2). If PID is\n            omitted, returns process group of current process. Note\n            that the POSIX version of `getpgrp()' does not accept a\n            PID argument, so only `PID==0' is truly portable.
getppid=    getppid Returns the process id of the parent process.
getpriority=    getpriority WHICH,WHO\n            Returns the current priority for a process, a process\n            group, or a user. (See the getpriority(2) manpage.) Will\n            raise a fatal exception if used on a machine that\n            doesn't implement getpriority(2).
getprotobyname=    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getprotobynumber=    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getprotoent=    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getpwnam=    getpwnam NAME\n    getgrnam NAME\n    gethostbyname NAME\n    getnetbyname NAME\n    getprotobyname NAME\n    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getpwuid=    getpwuid UID\n    getgrgid GID\n    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getservbyname=    getservbyname NAME,PROTO\n    gethostbyaddr ADDR,ADDRTYPE\n    getnetbyaddr ADDR,ADDRTYPE\n    getprotobynumber NUMBER\n    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getservbyport=    getservbyport PORT,PROTO\n    getpwent\n    getgrent\n    gethostent\n    getnetent\n    getprotoent\n    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getservent=    getservent\n    setpwent\n    setgrent\n    sethostent STAYOPEN\n    setnetent STAYOPEN\n    setprotoent STAYOPEN\n    setservent STAYOPEN\n    endpwent\n    endgrent\n    endhostent\n    endnetent\n    endprotoent\n    endservent\n            These routines perform the same functions as their\n            counterparts in the system library. In list context, the\n            return values from the various get routines are as\n            follows:\n                   $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                ($name,$passwd,$gid,$members) = getgr*\n                ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                ($name,$aliases,$addrtype,$net) = getnet*\n                ($name,$aliases,$proto) = getproto*\n                ($name,$aliases,$port,$proto) = getserv*\n\n            (If the entry doesn't exist you get a null list.)\n\n            In scalar context, you get the name, unless the function\n            was a lookup by name, in which case you get the other\n            thing, whatever it is. (If the entry doesn't exist you\n            get the undefined value.) For example:\n\n                $uid   = getpwnam($name);\n                $name  = getpwuid($num);\n                $name  = getpwent();\n                $gid   = getgrnam($name);\n                $name  = getgrgid($num;\n                $name  = getgrent();\n                #etc.\n\n            In *getpw*()* the fields `$quota', `$comment', and\n            `$expire' are special cases in the sense that in many\n            systems they are unsupported. If the `$quota' is\n            unsupported, it is an empty scalar. If it is supported,\n            it usually encodes the disk quota. If the `$comment'\n            field is unsupported, it is an empty scalar. If it is\n            supported it usually encodes some administrative comment\n            about the user. In some systems the $quota field may be\n            `$change' or `$age', fields that have to do with\n            password aging. In some systems the `$comment' field may\n            be `$class'. The `$expire' field, if present, encodes\n            the expiration period of the account or the password.\n            For the availability and the exact meaning of these\n            fields in your system, please consult your getpwnam(3)\n            documentation and your pwd.h file. You can also find out\n            from within Perl what your `$quota' and `$comment'\n            fields mean and whether you have the `$expire' field by\n            using the `Config' module and the values `d_pwquota',\n            `d_pwage', `d_pwchange', `d_pwcomment', and\n            `d_pwexpire'. Shadow password files are only supported\n            if your vendor has implemented them in the intuitive\n            fashion that calling the regular C library routines gets\n            the shadow versions if you're running under privilege.\n            Those that incorrectly implement a separate library call\n            are not supported.\n\n            The `$members' value returned by *getgr*()* is a space\n            separated list of the login names of the members of the\n            group.\n\n            For the *gethost*()* functions, if the `h_errno'\n            variable is supported in C, it will be returned to you\n            via `$?' if the function call fails. The `@addrs' value\n            returned by a successful call is a list of the raw\n            addresses returned by the corresponding system library\n            call. In the Internet domain, each address is four bytes\n            long and you can unpack it by saying something like:\n\n                ($a,$b,$c,$d) = unpack('C4',$addr[0]);\n\n            The Socket library makes this slightly easier:\n\n                use Socket;\n                $iaddr = inet_aton("127.1"); # or whatever address\n                $name  = gethostbyaddr($iaddr, AF_INET);\n\n                # or going the other way\n                $straddr = inet_ntoa($iaddr");\n\n            If you get tired of remembering which element of the\n            return list contains which return value, by-name\n            interfaces are also provided in modules: `File::stat',\n            `Net::hostent', `Net::netent', `Net::protoent',\n            `Net::servent', `Time::gmtime', `Time::localtime', and\n            `User::grent'. These override the normal built-in,\n            replacing them with versions that return objects with\n            the appropriate names for each field. For example:\n\n               use File::stat;\n               use User::pwent;\n               $is_his = (stat($filename)->uid == pwent($whoever)->uid);\n\n            Even though it looks like they're the same method calls\n            (uid), they aren't, because a `File::stat' object is\n            different from a `User::pwent' object.\n\n
getsockname=    getsockname SOCKET\n            Returns the packed sockaddr address of this end of the\n            SOCKET connection.\n                $mysockaddr = getsockname(SOCK);\n                ($port, $myaddr) = unpack_sockaddr_in($mysockaddr);\n\n
getsockopt=    getsockopt SOCKET,LEVEL,OPTNAME\n            Returns the socket option requested, or undef if there\n            is an error.
glob=    glob EXPR\n    glob    Returns the value of EXPR with filename expansions such as\n            the standard Unix shell /bin/csh would do. This is the\n            internal function implementing the `<*.c>' operator, but\n            you can use it directly. If EXPR is omitted, `$_' is\n            used. The `<*.c>' operator is discussed in more detail\n            in the section on "I/O Operators" in the perlop manpage.
gmtime=    gmtime EXPR\n            Converts a time as returned by the time function to a 9-\n            element array with the time localized for the standard\n            Greenwich time zone. Typically used as follows:\n                ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n                                                        gmtime(time);\n\n            All array elements are numeric, and come straight out of\n            a struct tm. In particular this means that `$mon' has\n            the range `0..11' and `$wday' has the range `0..6' with\n            sunday as day `0'. Also, `$year' is the number of years\n            since 1900, that is, `$year' is `123' in year 2023,\n            *not* simply the last two digits of the year. If you\n            assume it is, then you create non-Y2K-compliant\n            programs--and you wouldn't want to do that, would you?\n\n            If EXPR is omitted, does `gmtime(time())'.\n\n            In scalar context, returns the ctime(3) value:\n\n                $now_string = gmtime;  # e.g., "Thu Oct 13 04:54:34 1994"\n\n            Also see the `timegm()' function provided by the\n            `Time::Local' module, and the strftime(3) function\n            available via the POSIX module.\n\n            This scalar value is not locale dependent (see the\n            perllocale manpage), but is instead a Perl builtin. Also\n            see the `Time::Local' module, and the strftime(3) and\n            mktime(3) functions available via the POSIX module. To\n            get somewhat similar but locale dependent date strings,\n            set up your locale environment variables appropriately\n            (please see the perllocale manpage) and try for example:\n\n                use POSIX qw(strftime);\n                $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;\n\n            Note that the `%a' and `%b' escapes, which represent the\n            short forms of the day of the week and the month of the\n            year, may not necessarily be three characters wide in\n            all locales.\n\n
grep=    grep BLOCK LIST\n    grep EXPR,LIST\n            This is similar in spirit to, but not the same as,\n            grep(1) and its relatives. In particular, it is not\n            limited to using regular expressions.\n            (locally setting `$_' to each element) and returns the\n            list value consisting of those elements for which the\n            expression evaluated to TRUE. In scalar context, returns\n            the number of times the expression was TRUE.\n\n                @foo = grep(!/^#/, @bar);    # weed out comments\n\n            or equivalently,\n\n                @foo = grep {!/^#/} @bar;    # weed out comments\n\n            Note that, because `$_' is a reference into the list\n            value, it can be used to modify the elements of the\n            array. While this is useful and supported, it can cause\n            bizarre results if the LIST is not a named array.\n            Similarly, grep returns aliases into the original list,\n            much as a for loop's index variable aliases the list\n            elements. That is, modifying an element of a list\n            returned by grep (for example, in a `foreach', `map()'\n            or another `grep()') actually modifies the element in\n            the original list. This is usually something to be\n            avoided when writing clear code.\n\n            See also the map entry elsewhere in this document for an\n            array composed of the results of the BLOCK or EXPR.\n\n
hex=    hex EXPR\n    hex     Interprets EXPR as a hex string and returns the\n            corresponding value. (To convert strings that might\n            start with either 0, 0x, or 0b, see the oct entry\n            elsewhere in this document .) If EXPR is omitted, uses\n            `$_'.\n                print hex 'aF';   # same\n\n
import=    import  There is no builtin `import()' function. It is just an\n            ordinary method (subroutine) defined (or inherited) by\n            modules that wish to export names to another module. The\n            `use()' function calls the `import()' method for the\n            package used. See also the use() entry elsewhere in this\n            document the perlmod manpage, and the Exporter manpage.
index=    index STR,SUBSTR,POSITION\n    index STR,SUBSTR\n            The index function searches for one string within\n            another, but without the wildcard-like behavior of a\n            full regular-expression pattern match. It returns the\n            position of the first occurrence of SUBSTR in STR at or\n            after POSITION. If POSITION is omitted, starts searching\n            from the beginning of the string. The return value is\n            based at `0' (or whatever you've set the `$[' variable\n            to--but don't do that). If the substring is not found,\n            returns one less than the base, ordinarily `-1'.
int=    int EXPR\n    int     Returns the integer portion of EXPR. If EXPR is omitted,\n            uses `$_'. You should not use this function for\n            rounding: one because it truncates towards `0', and two\n            because machine representations of floating point\n            numbers can sometimes produce counterintuitive results.\n            For example, `int(-6.725/0.025)' produces -268 rather\n            than the correct -269; that's because it's really more\n            like -268.99999999999994315658 instead. Usually, the\n            `sprintf()', `printf()', or the `POSIX::floor' and\n            `POSIX::ceil' functions will serve you better than will\n            int().
ioctl=    ioctl FILEHANDLE,FUNCTION,SCALAR\n            Implements the ioctl(2) function. You'll probably first\n            have to say\n\n            to get the correct function definitions. If ioctl.ph\n            doesn't exist or doesn't have the correct definitions\n            you'll have to roll your own, based on your C header\n            files such as <sys/ioctl.h>. (There is a Perl script\n            called h2ph that comes with the Perl kit that may help\n            you in this, but it's nontrivial.) SCALAR will be read\n            and/or written depending on the FUNCTION--a pointer to\n            the string value of SCALAR will be passed as the third\n            argument of the actual `ioctl()' call. (If SCALAR has no\n            string value but does have a numeric value, that value\n            will be passed rather than a pointer to the string\n            value. To guarantee this to be TRUE, add a `0' to the\n            scalar before using it.) The `pack()' and `unpack()'\n            functions are useful for manipulating the values of\n            structures used by `ioctl()'. The following example sets\n            the erase character to DEL.\n\n                require 'ioctl.ph';\n                $getp = &TIOCGETP;\n                die "NO TIOCGETP" if $@ || !$getp;\n                $sgttyb_t = "ccccs";                # 4 chars and a short\n                if (ioctl(STDIN,$getp,$sgttyb)) {\n                    @ary = unpack($sgttyb_t,$sgttyb);\n                    $ary[2] = 127;\n                    $sgttyb = pack($sgttyb_t,@ary);\n                    ioctl(STDIN,&TIOCSETP,$sgttyb)\n                        || die "Can't ioctl: $!";\n                }\n\n            The return value of `ioctl()' (and `fcntl()') is as\n            follows:\n\n                    if OS returns:          then Perl returns:\n                        -1                    undefined value\n                         0                  string "0 but true"\n                    anything else               that number\n\n            Thus Perl returns TRUE on success and FALSE on failure,\n            yet you can still easily determine the actual value\n            returned by the operating system:\n\n                $retval = ioctl(...) || -1;\n                printf "System returned %d\\n", $retval;\n\n            The special string "`0' but true" is exempt from -w\n            complaints about improper numeric conversions.\n\n
join=    join EXPR,LIST\n            Joins the separate strings of LIST into a single string\n            with fields separated by the value of EXPR, and returns\n            that new string. Example:\n\n            See the split entry elsewhere in this document .\n\n
keys=    keys HASH\n            Returns a list consisting of all the keys of the named\n            hash. (In a scalar context, returns the number of keys.)\n            The keys are returned in an apparently random order. The\n            actual random order is subject to change in future\n            versions of perl, but it is guaranteed to be the same\n            order as either the `values()' or `each()' function\n            produces (given that the hash has not been modified). As\n            a side effect, it resets HASH's iterator.\n\n                @keys = keys %ENV;\n                @values = values %ENV;\n                while ($#keys >= 0) {\n                    print pop(@keys), '=', pop(@values), "\\n";\n                }\n\n            or how about sorted by key:\n\n                foreach $key (sort(keys %ENV)) {\n                    print $key, '=', $ENV{$key}, "\\n";\n                }\n\n            To sort a hash by value, you'll need to use a `sort()'\n            function. Here's a descending numeric sort of a hash by\n            its values:\n\n                foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {\n                    printf "%4d %s\\n", $hash{$key}, $key;\n                }\n\n            As an lvalue `keys()' allows you to increase the number\n            of hash buckets allocated for the given hash. This can\n            gain you a measure of efficiency if you know the hash is\n            going to get big. (This is similar to pre-extending an\n            array by assigning a larger number to $#array.) If you\n            say\n\n                keys %hash = 200;\n\n            then `%hash' will have at least 200 buckets allocated\n            for it--256 of them, in fact, since it rounds up to the\n            next power of two. These buckets will be retained even\n            if you do `%hash = ()', use `undef %hash' if you want to\n            free the storage while `%hash' is still in scope. You\n            can't shrink the number of buckets allocated for the\n            hash using `keys()' in this way (but you needn't worry\n            about doing this by accident, as trying has no effect).\n\n            See also `each()', `values()' and `sort()'.\n\n
kill=    kill LIST\n            Sends a signal to a list of processes. The first element\n            of the list must be the signal to send. Returns the\n            number of processes successfully signaled.\n                kill 9, @goners;\n\n            Unlike in the shell, in Perl if the *SIGNAL* is\n            negative, it kills process groups instead of processes.\n            (On System V, a negative *PROCESS* number will also kill\n            process groups, but that's not portable.) That means you\n            usually want to use positive not negative signals. You\n            may also use a signal name in quotes. See the section on\n            "Signals" in the perlipc manpage for details.\n\n
last=    last LABEL\n    last    The `last' command is like the `break' statement in C (as\n            used in loops); it immediately exits the loop in\n            question. If the LABEL is omitted, the command refers to\n            the innermost enclosing loop. The `continue' block, if\n            any, is not executed:\n                    last LINE if /^$/;      # exit when done with header\n                    #...\n                }\n\n            `last' cannot be used to exit a block which returns a\n            value such as `eval {}', `sub {}' or `do {}', and should\n            not be used to exit a grep() or map() operation.\n\n            See also the continue entry elsewhere in this document\n            for an illustration of how `last', `next', and `redo'\n            work.\n\n
lc=    lc EXPR\n    lc      Returns an lowercased version of EXPR. This is the internal\n            function implementing the `\\L' escape in double-quoted\n            strings. Respects current LC_CTYPE locale if `use\n            locale' in force. See the perllocale manpage.\n\n
lcfirst=    lcfirst EXPR\n    lcfirst Returns the value of EXPR with the first character\n            lowercased. This is the internal function implementing\n            the `\\l' escape in double-quoted strings. Respects\n            current LC_CTYPE locale if `use locale' in force. See\n            the perllocale manpage.\n\n
length=    length EXPR\n    length  Returns the length in characters of the value of EXPR. If\n            EXPR is omitted, returns length of `$_'. Note that this\n            cannot be used on an entire array or hash to find out\n            how many elements these have. For that, use `scalar\n            @array' and `scalar keys %hash' respectively.
link=    link OLDFILE,NEWFILE\n            Creates a new filename linked to the old filename.\n            Returns TRUE for success, FALSE otherwise.
listen=    listen SOCKET,QUEUESIZE\n            Does the same thing that the listen system call does.\n            Returns TRUE if it succeeded, FALSE otherwise. See the\n            example in the section on "Sockets: Client/Server\n            Communication" in the perlipc manpage.
local=    local EXPR\n            You really probably want to be using `my()' instead,\n            because `local()' isn't what most people think of as\n            "local". See the section on "Private Variables via my()"\n            in the perlsub manpage for details.\n            enclosing block, file, or eval. If more than one value\n            is listed, the list must be placed in parentheses. See\n            the section on "Temporary Values via local()" in the\n            perlsub manpage for details, including issues with tied\n            arrays and hashes.\n\n
localtime=    localtime EXPR\n            Converts a time as returned by the time function to a 9-\n            element array with the time analyzed for the local time\n            zone. Typically used as follows:\n                ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n                                                            localtime(time);\n\n            All array elements are numeric, and come straight out of\n            a struct tm. In particular this means that `$mon' has\n            the range `0..11' and `$wday' has the range `0..6' with\n            sunday as day `0'. Also, `$year' is the number of years\n            since 1900, that is, `$year' is `123' in year 2023, and\n            *not* simply the last two digits of the year. If you\n            assume it is, then you create non-Y2K-compliant\n            programs--and you wouldn't want to do that, would you?\n\n            If EXPR is omitted, uses the current time\n            (`localtime(time)').\n\n            In scalar context, returns the ctime(3) value:\n\n                $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"\n\n            This scalar value is not locale dependent, see the\n            perllocale manpage, but instead a Perl builtin. Also see\n            the `Time::Local' module, and the strftime(3) and\n            mktime(3) function available via the POSIX module. To\n            get somewhat similar but locale dependent date strings,\n            set up your locale environment variables appropriately\n            (please see the perllocale manpage) and try for example:\n\n                use POSIX qw(strftime);\n                $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;\n\n            Note that the `%a' and `%b', the short forms of the day\n            of the week and the month of the year, may not\n            necessarily be three characters wide.\n\n
log=    log EXPR\n    log     Returns the natural logarithm (base *e*) of EXPR. If EXPR is\n            omitted, returns log of `$_'. To get the log of another\n            base, use basic algebra: The base-N log of a number is\n            is equal to the natural log of that number divided by\n            the natural log of N. For example:\n                    my $n = shift;\n                    return log($n)/log(10);\n                } \n\n            See also the exp entry elsewhere in this document for\n            the inverse operation.\n\n
m=    m//     The match operator. See the perlop manpage.
map=    map BLOCK LIST\n    map EXPR,LIST\n            Evaluates the BLOCK or EXPR for each element of LIST\n            (locally setting `$_' to each element) and returns the\n            list value composed of the results of each such\n            evaluation. Evaluates BLOCK or EXPR in a list context,\n            so each element of LIST may produce zero, one, or more\n            elements in the returned value.\n            so generated.\n\n                @chars = map(chr, @nums);\n\n            translates a list of numbers to the corresponding\n            characters. And\n\n                %hash = map { getkey($_) => $_ } @array;\n\n            is just a funny way to write\n\n                %hash = ();\n                foreach $_ (@array) {\n                    $hash{getkey($_)} = $_;\n                }\n\n            Note that, because `$_' is a reference into the list\n            value, it can be used to modify the elements of the\n            array. While this is useful and supported, it can cause\n            bizarre results if the LIST is not a named array. Using\n            a regular `foreach' loop for this purpose would be\n            clearer in most cases. See also the grep entry elsewhere\n            in this document for an array composed of those items of\n            the original list for which the BLOCK or EXPR evaluates\n            to true.\n\n
mkdir=    mkdir FILENAME,MODE\n            Creates the directory specified by FILENAME, with\n            permissions specified by MODE (as modified by `umask').\n            If it succeeds it returns TRUE, otherwise it returns\n            FALSE and sets `$!' (errno).\n            permissive MODEs, and let the user modify that with\n            their `umask', than it is to supply a restrictive MODE\n            and give the user no way to be more permissive. The\n            exceptions to this rule are when the file or directory\n            should be kept private (mail files, for instance). The\n            perlfunc(1) entry on `umask' discusses the choice of\n            MODE in more detail.\n\n
msgctl=    msgctl ID,CMD,ARG\n            Calls the System V IPC function msgctl(2). You'll\n            probably have to say\n\n            first to get the correct constant definitions. If CMD is\n            `IPC_STAT', then ARG must be a variable which will hold\n            the returned `msqid_ds' structure. Returns like\n            `ioctl()': the undefined value for error, "`0' but true"\n            for zero, or the actual return value otherwise. See also\n            `IPC::SysV' and `IPC::Semaphore::Msg' documentation.\n\n
msgget=    msgget KEY,FLAGS\n            Calls the System V IPC function msgget(2). Returns the\n            message queue id, or the undefined value if there is an\n            error. See also `IPC::SysV' and `IPC::SysV::Msg'\n            documentation.
msgrcv=    msgrcv ID,VAR,SIZE,TYPE,FLAGS\n            Calls the System V IPC function msgrcv to receive a\n            message from message queue ID into variable VAR with a\n            maximum message size of SIZE. Note that if a message is\n            received, the message type will be the first thing in\n            VAR, and the maximum length of VAR is SIZE plus the size\n            of the message type. Returns TRUE if successful, or\n            FALSE if there is an error. See also `IPC::SysV' and\n            `IPC::SysV::Msg' documentation.
msgsnd=    msgsnd ID,MSG,FLAGS\n            Calls the System V IPC function msgsnd to send the\n            message MSG to the message queue ID. MSG must begin with\n            the long integer message type, which may be created with\n            `pack("l", $type)'. Returns TRUE if successful, or FALSE\n            if there is an error. See also `IPC::SysV' and\n            `IPC::SysV::Msg' documentation.
my=    my EXPR A `my()' declares the listed variables to be local\n            (lexically) to the enclosing block, file, or `eval()'.\n            If more than one value is listed, the list must be\n            placed in parentheses. See the section on "Private\n            Variables via my()" in the perlsub manpage for details.
next=    next LABEL\n    next    The `next' command is like the `continue' statement in C; it\n            starts the next iteration of the loop:\n                    next LINE if /^#/;      # discard comments\n                    #...\n                }\n\n            Note that if there were a `continue' block on the above,\n            it would get executed even on discarded lines. If the\n            LABEL is omitted, the command refers to the innermost\n            enclosing loop.\n\n            `next' cannot be used to exit a block which returns a\n            value such as `eval {}', `sub {}' or `do {}', and should\n            not be used to exit a grep() or map() operation.\n\n            See also the continue entry elsewhere in this document\n            for an illustration of how `last', `next', and `redo'\n            work.\n\n
no=    no Module LIST\n            See the the use entry elsewhere in this document\n            function, which `no' is the opposite of.
oct=    oct EXPR\n    oct     Interprets EXPR as an octal string and returns the\n            corresponding value. (If EXPR happens to start off with\n            `0x', interprets it as a hex string. If EXPR starts off\n            with `0b', it is interpreted as a binary string.) The\n            following will handle decimal, binary, octal, and hex in\n            the standard Perl or C notation:\n\n            If EXPR is omitted, uses `$_'. This function is commonly\n            used when a string such as `644' needs to be converted\n            into a file mode, for example. (Although perl will\n            automatically convert strings into numbers as needed,\n            this automatic conversion assumes base 10.)\n\n
open=    open FILEHANDLE,EXPR\n    open FILEHANDLE\n            Opens the file whose filename is given by EXPR, and\n            associates it with FILEHANDLE. If FILEHANDLE is an\n            expression, its value is used as the name of the real\n            filehandle wanted. If EXPR is omitted, the scalar\n            variable of the same name as the FILEHANDLE contains the\n            filename. (Note that lexical variables--those declared\n            with `my()'--will not work for this purpose; so if\n            you're using `my()', specify EXPR in your call to open.)\n            See the perlopentut manpage for a kinder, gentler\n            explanation of opening files.\n            is opened for input. If the filename begins with `'>'',\n            the file is truncated and opened for output, being\n            created if necessary. If the filename begins with\n            `'>>'', the file is opened for appending, again being\n            created if necessary. You can put a `'+'' in front of\n            the `'>'' or `'<'' to indicate that you want both read\n            and write access to the file; thus `'+<'' is almost\n            always preferred for read/write updates--the `'+>'' mode\n            would clobber the file first. You can't usually use\n            either read-write mode for updating textfiles, since\n            they have variable length records. See the -i switch in\n            the perlrun manpage for a better approach. The file is\n            created with permissions of `0666' modified by the\n            process' `umask' value.\n\n            The prefix and the filename may be separated with\n            spaces. These various prefixes correspond to the\n            fopen(3) modes of `'r'', `'r+'', `'w'', `'w+'', `'a'',\n            and `'a+''.\n\n            If the filename begins with `'|'', the filename is\n            interpreted as a command to which output is to be piped,\n            and if the filename ends with a `'|'', the filename is\n            interpreted as a command which pipes output to us. See\n            the section on "Using open() for IPC" in the perlipc\n            manpage for more examples of this. (You are not allowed\n            to `open()' to a command that pipes both in *and* out,\n            but see the IPC::Open2 manpage, the IPC::Open3 manpage,\n            and the section on "Bidirectional Communication" in the\n            perlipc manpage for alternatives.)\n\n            Opening `'-'' opens STDIN and opening `'>-'' opens\n            STDOUT. Open returns nonzero upon success, the undefined\n            value otherwise. If the `open()' involved a pipe, the\n            return value happens to be the pid of the subprocess.\n\n            If you're unfortunate enough to be running Perl on a\n            system that distinguishes between text files and binary\n            files (modern operating systems don't care), then you\n            should check out the binmode entry elsewhere in this\n            document for tips for dealing with this. The key\n            distinction between systems that need `binmode()' and\n            those that don't is their text file formats. Systems\n            like Unix, MacOS, and Plan9, which delimit lines with a\n            single character, and which encode that character in C\n            as `"\\n"', do not need `binmode()'. The rest need it.\n\n            When opening a file, it's usually a bad idea to continue\n            normal execution if the request failed, so `open()' is\n            frequently used in connection with `die()'. Even if\n            `die()' won't do what you want (say, in a CGI script,\n            where you want to make a nicely formatted error message\n            (but there are modules that can help with that problem))\n            you should always check the return value from opening a\n            file. The infrequent exception is when working with an\n            unopened filehandle is actually what you want to do.\n\n            Examples:\n\n                $ARTICLE = 100;\n                open ARTICLE or die "Can't find article $ARTICLE: $!\\n";\n                while (<ARTICLE>) {...\n\n                open(LOG, '>>/usr/spool/news/twitlog'); # (log is reserved)\n                # if the open fails, output is discarded\n\n                open(DBASE, '+<dbase.mine')             # open for update\n                    or die "Can't open 'dbase.mine' for update: $!";\n\n                open(ARTICLE, "caesar <$article |")     # decrypt article\n                    or die "Can't start caesar: $!";\n\n                open(EXTRACT, "|sort >/tmp/Tmp$$")      # $$ is our process id\n                    or die "Can't start sort: $!";\n\n                # process argument list of files along with any includes\n\n                foreach $file (@ARGV) {\n                    process($file, 'fh00');\n                }\n\n                sub process {\n                    my($filename, $input) = @_;\n                    $input++;               # this is a string increment\n                    unless (open($input, $filename)) {\n                        print STDERR "Can't open $filename: $!\\n";\n                        return;\n                    }\n\n                    local $_;\n                    while (<$input>) {              # note use of indirection\n                        if (/^#include "(.*)"/) {\n                            process($1, $input);\n                            next;\n                        }\n                        #...                # whatever\n                    }\n                }\n\n            You may also, in the Bourne shell tradition, specify an\n            EXPR beginning with `'>&'', in which case the rest of\n            the string is interpreted as the name of a filehandle\n            (or file descriptor, if numeric) to be duped and opened.\n            You may use `&' after `>', `>>', `<', `+>', `+>>', and\n            `+<'. The mode you specify should match the mode of the\n            original filehandle. (Duping a filehandle does not take\n            into account any existing contents of stdio buffers.)\n            Here is a script that saves, redirects, and restores\n            STDOUT and STDERR:\n\n                #!/usr/bin/perl\n                open(OLDOUT, ">&STDOUT");\n                open(OLDERR, ">&STDERR");\n\n                open(STDOUT, ">foo.out") || die "Can't redirect stdout";\n                open(STDERR, ">&STDOUT") || die "Can't dup stdout";\n\n                select(STDERR); $| = 1;     # make unbuffered\n                select(STDOUT); $| = 1;     # make unbuffered\n\n                print STDOUT "stdout 1\\n";  # this works for\n                print STDERR "stderr 1\\n";  # subprocesses too\n\n                close(STDOUT);\n                close(STDERR);\n\n                open(STDOUT, ">&OLDOUT");\n                open(STDERR, ">&OLDERR");\n\n                print STDOUT "stdout 2\\n";\n                print STDERR "stderr 2\\n";\n\n            If you specify `'<&=N'', where `N' is a number, then\n            Perl will do an equivalent of C's `fdopen()' of that\n            file descriptor; this is more parsimonious of file\n            descriptors. For example:\n\n                open(FILEHANDLE, "<&=$fd")\n\n            If you open a pipe on the command `'-'', i.e., either\n            `'|-'' or `'-|'', then there is an implicit fork done,\n            and the return value of open is the pid of the child\n            within the parent process, and `0' within the child\n            process. (Use `defined($pid)' to determine whether the\n            open was successful.) The filehandle behaves normally\n            for the parent, but i/o to that filehandle is piped\n            from/to the STDOUT/STDIN of the child process. In the\n            child process the filehandle isn't opened--i/o happens\n            from/to the new STDOUT or STDIN. Typically this is used\n            like the normal piped open when you want to exercise\n            more control over just how the pipe command gets\n            executed, such as when you are running setuid, and don't\n            want to have to scan shell commands for metacharacters.\n            The following pairs are more or less equivalent:\n\n                open(FOO, "|tr '[a-z]' '[A-Z]'");\n                open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';\n\n                open(FOO, "cat -n '$file'|");\n                open(FOO, "-|") || exec 'cat', '-n', $file;\n\n            See the section on "Safe Pipe Opens" in the perlipc\n            manpage for more examples of this.\n\n            NOTE: On any operation that may do a fork, any unflushed\n            buffers remain unflushed in both processes, which means\n            you may need to set `$|' to avoid duplicate output. On\n            systems that support a close-on-exec flag on files, the\n            flag will be set for the newly opened file descriptor as\n            determined by the value of $^F. See the section on "$^F"\n            in the perlvar manpage.\n\n            Closing any piped filehandle causes the parent process\n            to wait for the child to finish, and returns the status\n            value in `$?'.\n\n            The filename passed to open will have leading and\n            trailing whitespace deleted, and the normal redirection\n            characters honored. This property, known as "magic\n            open", can often be used to good effect. A user could\n            specify a filename of "rsh cat file |", or you could\n            change certain filenames as needed:\n\n                $filename =~ s/(.*\\.gz)\\s*$/gzip -dc < $1|/;\n                open(FH, $filename) or die "Can't open $filename: $!";\n\n            However, to open a file with arbitrary weird characters\n            in it, it's necessary to protect any leading and\n            trailing whitespace:\n\n                $file =~ s#^(\\s)#./$1#;\n                open(FOO, "< $file\\0");\n\n            If you want a "real" C `open()' (see the open(2) manpage\n            on your system), then you should use the `sysopen()'\n            function, which involves no such magic. This is another\n            way to protect your filenames from interpretation. For\n            example:\n\n                use IO::Handle;\n                sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)\n                    or die "sysopen $path: $!";\n                $oldfh = select(HANDLE); $| = 1; select($oldfh);\n                print HANDLE "stuff $$\\n");\n                seek(HANDLE, 0, 0);\n                print "File contains: ", <HANDLE>;\n\n            Using the constructor from the `IO::Handle' package (or\n            one of its subclasses, such as `IO::File' or\n            `IO::Socket'), you can generate anonymous filehandles\n            that have the scope of whatever variables hold\n            references to them, and automatically close whenever and\n            however you leave that scope:\n\n                use IO::File;\n                #...\n                sub read_myfile_munged {\n                    my $ALL = shift;\n                    my $handle = new IO::File;\n                    open($handle, "myfile") or die "myfile: $!";\n                    $first = <$handle>\n                        or return ();     # Automatically closed here.\n                    mung $first or die "mung failed";       # Or here.\n                    return $first, <$handle> if $ALL;       # Or here.\n                    $first;                                 # Or here.\n                }\n\n            See the seek entry elsewhere in this document for some\n            details about mixing reading and writing.\n\n
opendir=    opendir DIRHANDLE,EXPR\n            Opens a directory named EXPR for processing by\n            `readdir()', `telldir()', `seekdir()', `rewinddir()',\n            and `closedir()'. Returns TRUE if successful. DIRHANDLEs\n            have their own namespace separate from FILEHANDLEs.
ord=    ord EXPR\n    ord     Returns the numeric ascii value of the first character of\n            EXPR. If EXPR is omitted, uses `$_'. For the reverse,\n            see the chr entry elsewhere in this document .
pack=    pack TEMPLATE,LIST\n            Takes an array or list of values and packs it into a\n            binary structure, returning the string containing the\n            structure. The TEMPLATE is a sequence of characters that\n            give the order and type of values, as follows:\n                A   An ascii string, will be space padded.\n                Z   A null terminated (asciz) string, will be null padded.\n\n                b   A bit string (ascending bit order, like vec()).\n                B   A bit string (descending bit order).\n                h   A hex string (low nybble first).\n                H   A hex string (high nybble first).\n\n                c   A signed char value.\n                C   An unsigned char value.\n\n                s   A signed short value.\n                S   An unsigned short value.\n                      (This 'short' is _exactly_ 16 bits, which may differ from\n                       what a local C compiler calls 'short'.)\n\n                i   A signed integer value.\n                I   An unsigned integer value.\n                      (This 'integer' is _at least_ 32 bits wide.  Its exact\n                       size depends on what a local C compiler calls 'int',\n                       and may even be larger than the 'long' described in\n                       the next item.)\n\n                l   A signed long value.\n                L   An unsigned long value.\n                      (This 'long' is _exactly_ 32 bits, which may differ from\n                       what a local C compiler calls 'long'.)\n\n                n   A short in "network" (big-endian) order.\n                N   A long in "network" (big-endian) order.\n                v   A short in "VAX" (little-endian) order.\n                V   A long in "VAX" (little-endian) order.\n                      (These 'shorts' and 'longs' are _exactly_ 16 bits and\n                       _exactly_ 32 bits, respectively.)\n\n                q   A signed quad (64-bit) value.\n                Q   An unsigned quad value.\n                      (Available only if your system supports 64-bit integer values\n                       _and_ if Perl has been compiled to support those.\n                       Causes a fatal error otherwise.)\n\n                f   A single-precision float in the native format.\n                d   A double-precision float in the native format.\n\n                p   A pointer to a null-terminated string.\n                P   A pointer to a structure (fixed-length string).\n\n                u   A uuencoded string.\n\n                w   A BER compressed integer.  Its bytes represent an unsigned\n                    integer in base 128, most significant digit first, with as\n                    few digits as possible.  Bit eight (the high bit) is set\n                    on each byte except the last.\n\n                x   A null byte.\n                X   Back up a byte.\n                @   Null fill to absolute position.\n\n            The following rules apply:\n\n
package=    package\n    package NAMESPACE\n            Declares the compilation unit as being in the given\n            namespace. The scope of the package declaration is from\n            the declaration itself through the end of the enclosing\n            block, file, or eval (the same as the `my()' operator).\n            All further unqualified dynamic identifiers will be in\n            this namespace. A package statement affects only dynamic\n            variables--including those you've used `local()' on--but\n            *not* lexical variables, which are created with `my()'.\n            Typically it would be the first declaration in a file to\n            be included by the `require' or `use' operator. You can\n            switch into a package in more than one place; it merely\n            influences which symbol table is used by the compiler\n            for the rest of that block. You can refer to variables\n            and filehandles in other packages by prefixing the\n            identifier with the package name and a double colon:\n            `$Package::Variable'. If the package name is null, the\n            `main' package as assumed. That is, `$::sail' is\n            equivalent to `$main::sail' (as well as to `$main'sail',\n            still seen in older code).\n            package, and all identifiers must be fully qualified or\n            lexicals. This is stricter than `use strict', since it\n            also extends to function names.\n\n            See the section on "Packages" in the perlmod manpage for\n            more information about packages, modules, and classes.\n            See the perlsub manpage for other scoping issues.\n\n
pipe=    pipe READHANDLE,WRITEHANDLE\n            Opens a pair of connected pipes like the corresponding\n            system call. Note that if you set up a loop of piped\n            processes, deadlock can occur unless you are very\n            careful. In addition, note that Perl's pipes use stdio\n            buffering, so you may need to set `$|' to flush your\n            WRITEHANDLE after each command, depending on the\n            application.\n            the section on "Bidirectional Communication" in the\n            perlipc manpage for examples of such things.\n\n            On systems that support a close-on-exec flag on files,\n            the flag will be set for the newly opened file\n            descriptors as determined by the value of $^F. See the\n            section on "$^F" in the perlvar manpage.\n\n
pop=    pop ARRAY\n    pop     Pops and returns the last value of the array, shortening the\n            array by one element. Has a similar effect to\n\n            If there are no elements in the array, returns the\n            undefined value. If ARRAY is omitted, pops the `@ARGV'\n            array in the main program, and the `@_' array in\n            subroutines, just like `shift()'.\n\n
pos=    pos SCALAR\n    pos     Returns the offset of where the last `m//g' search left off\n            for the variable is in question (`$_' is used when the\n            variable is not specified). May be modified to change\n            that offset. Such modification will also influence the\n            `\\G' zero-width assertion in regular expressions. See\n            the perlre manpage and the perlop manpage.
print=    print FILEHANDLE LIST\n    print LIST\n    print   Prints a string or a comma-separated list of strings.\n            Returns TRUE if successful. FILEHANDLE may be a scalar\n            variable name, in which case the variable contains the\n            name of or a reference to the filehandle, thus\n            introducing one level of indirection. (NOTE: If\n            FILEHANDLE is a variable and the next token is a term,\n            it may be misinterpreted as an operator unless you\n            interpose a `+' or put parentheses around the\n            arguments.) If FILEHANDLE is omitted, prints by default\n            to standard output (or to the last selected output\n            channel--see the select entry elsewhere in this document\n            ). If LIST is also omitted, prints `$_' to the currently\n            selected output channel. To set the default output\n            channel to something other than STDOUT use the select\n            operation. Note that, because print takes a LIST,\n            anything in the LIST is evaluated in list context, and\n            any subroutine that you call will have one or more of\n            its expressions evaluated in list context. Also be\n            careful not to follow the print keyword with a left\n            parenthesis unless you want the corresponding right\n            parenthesis to terminate the arguments to the print--\n            interpose a `+' or put parentheses around all the\n            arguments.\n            other expression, you will have to use a block returning\n            its value instead:\n\n                print { $files[$i] } "stuff\\n";\n                print { $OK ? STDOUT : STDERR } "stuff\\n";\n\n
printf=    printf FILEHANDLE FORMAT, LIST\n    printf FORMAT, LIST\n            Equivalent to `print FILEHANDLE sprintf(FORMAT, LIST)',\n            except that `$\\' (the output record separator) is not\n            appended. The first argument of the list will be\n            interpreted as the `printf()' format. If `use locale' is\n            in effect, the character used for the decimal point in\n            formatted real numbers is affected by the LC_NUMERIC\n            locale. See the perllocale manpage.\n            simple `print()' would do. The `print()' is more\n            efficient and less error prone.\n\n
prototype=    prototype FUNCTION\n            Returns the prototype of a function as a string (or\n            `undef' if the function has no prototype). FUNCTION is a\n            reference to, or the name of, the function whose\n            prototype you want to retrieve.\n            is taken as a name for Perl builtin. If the builtin is\n            not *overridable* (such as `qw//') or its arguments\n            cannot be expressed by a prototype (such as `system()')\n            returns `undef' because the builtin does not really\n            behave like a Perl function. Otherwise, the string\n            describing the equivalent prototype is returned.\n\n
push=    push ARRAY,LIST\n            Treats ARRAY as a stack, and pushes the values of LIST\n            onto the end of ARRAY. The length of ARRAY increases by\n            the length of LIST. Has the same effect as\n                    $ARRAY[++$#ARRAY] = $value;\n                }\n\n            but is more efficient. Returns the new number of\n            elements in the array.\n\n
q=    q/STRING/\n    qq/STRING/\n    qr/STRING/\n    qx/STRING/\n    qw/STRING/\n            Generalized quotes. See the section on "Regexp Quote-\n            Like Operators" in the perlop manpage.
quotemeta=    quotemeta EXPR\n    quotemeta\n            Returns the value of EXPR with all non-alphanumeric\n            characters backslashed. (That is, all characters not\n            matching `/[A-Za-z_0-9]/' will be preceded by a\n            backslash in the returned string, regardless of any\n            locale settings.) This is the internal function\n            implementing the `\\Q' escape in double-quoted strings.\n\n
rand=    rand EXPR\n    rand    Returns a random fractional number greater than or equal to\n            `0' and less than the value of EXPR. (EXPR should be\n            positive.) If EXPR is omitted, the value `1' is used.\n            Automatically calls `srand()' unless `srand()' has\n            already been called. See also `srand()'.\n            numbers that are too large or too small, then your\n            version of Perl was probably compiled with the wrong\n            number of RANDBITS.)\n\n
read=    read FILEHANDLE,SCALAR,LENGTH,OFFSET\n    read FILEHANDLE,SCALAR,LENGTH\n            Attempts to read LENGTH bytes of data into variable\n            SCALAR from the specified FILEHANDLE. Returns the number\n            of bytes actually read, `0' at end of file, or undef if\n            there was an error. SCALAR will be grown or shrunk to\n            the length actually read. An OFFSET may be specified to\n            place the read data at some other place than the\n            beginning of the string. This call is actually\n            implemented in terms of stdio's fread(3) call. To get a\n            true read(2) system call, see `sysread()'.
readdir=    readdir DIRHANDLE\n            Returns the next directory entry for a directory opened\n            by `opendir()'. If used in list context, returns all the\n            rest of the entries in the directory. If there are no\n            more entries, returns an undefined value in scalar\n            context or a null list in list context.\n            a `readdir()', you'd better prepend the directory in\n            question. Otherwise, because we didn't `chdir()' there,\n            it would have been testing the wrong file.\n\n                opendir(DIR, $some_dir) || die "can't opendir $some_dir: $!";\n                @dots = grep { /^\\./ && -f "$some_dir/$_" } readdir(DIR);\n                closedir DIR;\n\n
readline=    readline EXPR\n            Reads from the filehandle whose typeglob is contained in\n            EXPR. In scalar context, each call reads and returns the\n            next line, until end-of-file is reached, whereupon the\n            subsequent call returns undef. In list context, reads\n            until end-of-file is reached and returns a list of\n            lines. Note that the notion of "line" used here is\n            however you may have defined it with `$/' or\n            `$INPUT_RECORD_SEPARATOR'). See the section on "$/" in\n            the perlvar manpage.\n            scalar context (i.e. file slurp mode), and when an empty\n            file is read, it returns `''' the first time, followed\n            by `undef' subsequently.\n\n            This is the internal function implementing the `<EXPR>'\n            operator, but you can use it directly. The `<EXPR>'\n            operator is discussed in more detail in the section on\n            "I/O Operators" in the perlop manpage.\n\n                $line = <STDIN>;\n                $line = readline(*STDIN);           # same thing\n\n
readlink=    readlink EXPR\n    readlink\n            Returns the value of a symbolic link, if symbolic links\n            are implemented. If not, gives a fatal error. If there\n            is some system error, returns the undefined value and\n            sets `$!' (errno). If EXPR is omitted, uses `$_'.
readpipe=    readpipe EXPR\n            EXPR is executed as a system command. The collected\n            standard output of the command is returned. In scalar\n            context, it comes back as a single (potentially multi-\n            line) string. In list context, returns a list of lines\n            (however you've defined lines with `$/' or\n            `$INPUT_RECORD_SEPARATOR'). This is the internal\n            function implementing the `qx/EXPR/' operator, but you\n            can use it directly. The `qx/EXPR/' operator is\n            discussed in more detail in the section on "I/O\n            Operators" in the perlop manpage.
recv=    recv SOCKET,SCALAR,LENGTH,FLAGS\n            Receives a message on a socket. Attempts to receive\n            LENGTH bytes of data into variable SCALAR from the\n            specified SOCKET filehandle. Actually does a C\n            `recvfrom()', so that it can return the address of the\n            sender. Returns the undefined value if there's an error.\n            SCALAR will be grown or shrunk to the length actually\n            read. Takes the same flags as the system call of the\n            same name. See the section on "UDP: Message Passing" in\n            the perlipc manpage for examples.
redo=    redo LABEL\n    redo    The `redo' command restarts the loop block without\n            evaluating the conditional again. The `continue' block,\n            if any, is not executed. If the LABEL is omitted, the\n            command refers to the innermost enclosing loop. This\n            command is normally used by programs that want to lie to\n            themselves about what was just input:\n                # (warning: assumes no { or } in strings)\n                LINE: while (<STDIN>) {\n                    while (s|({.*}.*){.*}|$1 |) {}\n                    s|{.*}| |;\n                    if (s|{.*| |) {\n                        $front = $_;\n                        while (<STDIN>) {\n                            if (/}/) {      # end of comment?\n                                s|^|$front\\{|;\n                                redo LINE;\n                            }\n                        }\n                    }\n                    print;\n                }\n\n            `redo' cannot be used to retry a block which returns a\n            value such as `eval {}', `sub {}' or `do {}', and should\n            not be used to exit a grep() or map() operation.\n\n            See also the continue entry elsewhere in this document\n            for an illustration of how `last', `next', and `redo'\n            work.\n\n
ref=    ref EXPR\n    ref     Returns a TRUE value if EXPR is a reference, FALSE\n            otherwise. If EXPR is not specified, `$_' will be used.\n            The value returned depends on the type of thing the\n            reference is a reference to. Builtin types include:\n                SCALAR\n                ARRAY\n                HASH\n                CODE\n                GLOB\n\n            If the referenced object has been blessed into a\n            package, then that package name is returned instead. You\n            can think of `ref()' as a `typeof()' operator.\n\n                if (ref($r) eq "HASH") {\n                    print "r is a reference to a hash.\\n";\n                }\n                unless (ref($r)) {\n                    print "r is not a reference at all.\\n";\n                }\n                if (UNIVERSAL::isa($r, "HASH")) {  # for subclassing\n                    print "r is a reference to something that isa hash.\\n";\n                } \n\n            See also the perlref manpage.\n\n
rename=    rename OLDNAME,NEWNAME\n            Changes the name of a file. Returns `1' for success, `0'\n            otherwise. Behavior of this function varies wildly\n            depending on your system implementation. For example, it\n            will usually not work across file system boundaries,\n            even though the system *mv* command sometimes\n            compensates for this. Other restrictions include whether\n            it works on directories, open files, or pre-existing\n            files. Check the perlport manpage and either the\n            rename(2) manpage or equivalent system documentation for\n            details.
require=    require EXPR\n    require Demands some semantics specified by EXPR, or by `$_' if EXPR\n            is not supplied. If EXPR is numeric, demands that the\n            current version of Perl (`$]' or $PERL_VERSION) be equal\n            or greater than EXPR.\n            hasn't already been included. The file is included via\n            the do-FILE mechanism, which is essentially just a\n            variety of `eval()'. Has semantics similar to the\n            following subroutine:\n\n                sub require {\n                    my($filename) = @_;\n                    return 1 if $INC{$filename};\n                    my($realfilename,$result);\n                    ITER: {\n                        foreach $prefix (@INC) {\n                            $realfilename = "$prefix/$filename";\n                            if (-f $realfilename) {\n                                $result = do $realfilename;\n                                last ITER;\n                            }\n                        }\n                        die "Can't find $filename in \\@INC";\n                    }\n                    die $@ if $@;\n                    die "$filename did not return true value" unless $result;\n                    $INC{$filename} = $realfilename;\n                    return $result;\n                }\n\n            Note that the file will not be included twice under the\n            same specified name. The file must return TRUE as the\n            last statement to indicate successful execution of any\n            initialization code, so it's customary to end such a\n            file with "`1;'" unless you're sure it'll return TRUE\n            otherwise. But it's better just to put the "`1;'", in\n            case you add more statements.\n\n            If EXPR is a bareword, the require assumes a ".pm"\n            extension and replaces "::" with "/" in the filename for\n            you, to make it easy to load standard modules. This form\n            of loading of modules does not risk altering your\n            namespace.\n\n            In other words, if you try this:\n\n                    require Foo::Bar;    # a splendid bareword \n\n            The require function will actually look for the\n            "Foo/Bar.pm" file in the directories specified in the\n            `@INC' array.\n\n            But if you try this:\n\n                    $class = 'Foo::Bar';\n                    require $class;      # $class is not a bareword\n                #or\n                    require "Foo::Bar";  # not a bareword because of the ""\n\n            The require function will look for the "Foo::Bar" file\n            in the @INC array and will complain about not finding\n            "Foo::Bar" there. In this case you can do:\n\n                    eval "require $class";\n\n            For a yet-more-powerful import facility, see the use\n            entry elsewhere in this document the perlmod manpage.\n\n
reset=    reset EXPR\n    reset   Generally used in a `continue' block at the end of a loop to\n            clear variables and reset `??' searches so that they\n            work again. The expression is interpreted as a list of\n            single characters (hyphens allowed for ranges). All\n            variables and arrays beginning with one of those letters\n            are reset to their pristine state. If the expression is\n            omitted, one-match searches (`?pattern?') are reset to\n            match again. Resets only variables or searches in the\n            current package. Always returns 1. Examples:\n                reset 'a-z';        # reset lower case variables\n                reset;              # just reset ?one-time? searches\n\n            Resetting `"A-Z"' is not recommended because you'll wipe\n            out your `@ARGV' and `@INC' arrays and your `%ENV' hash.\n            Resets only package variables--lexical variables are\n            unaffected, but they clean themselves up on scope exit\n            anyway, so you'll probably want to use them instead. See\n            the my entry elsewhere in this document .\n\n
return=    return EXPR\n    return  Returns from a subroutine, `eval()', or `do FILE' with the\n            value given in EXPR. Evaluation of EXPR may be in list,\n            scalar, or void context, depending on how the return\n            value will be used, and the context may vary from one\n            execution to the next (see `wantarray()'). If no EXPR is\n            given, returns an empty list in list context, the\n            undefined value in scalar context, and (of course)\n            nothing at all in a void context.\n            subroutine, eval, or do FILE will automatically return\n            the value of the last expression evaluated.)\n\n
reverse=    reverse LIST\n            In list context, returns a list value consisting of the\n            elements of LIST in the opposite order. In scalar\n            context, concatenates the elements of LIST and returns a\n            string value with all characters in the opposite order.\n\n                undef $/;                   # for efficiency of <>\n                print scalar reverse <>;    # character tac, last line tsrif\n\n            This operator is also handy for inverting a hash,\n            although there are some caveats. If a value is\n            duplicated in the original hash, only one of those can\n            be represented as a key in the inverted hash. Also, this\n            has to unwind one hash and build a whole new one, which\n            may take some time on a large hash, such as from a DBM\n            file.\n\n                %by_name = reverse %by_address;     # Invert the hash\n\n
rewinddir=    rewinddir DIRHANDLE\n            Sets the current position to the beginning of the\n            directory for the `readdir()' routine on DIRHANDLE.
rindex=    rindex STR,SUBSTR,POSITION\n    rindex STR,SUBSTR\n            Works just like index() except that it returns the\n            position of the LAST occurrence of SUBSTR in STR. If\n            POSITION is specified, returns the last occurrence at or\n            before that position.
rmdir=    rmdir FILENAME\n    rmdir   Deletes the directory specified by FILENAME if that\n            directory is empty. If it succeeds it returns TRUE,\n            otherwise it returns FALSE and sets `$!' (errno). If\n            FILENAME is omitted, uses `$_'.
s=    s///    The substitution operator. See the perlop manpage.
scalar=    scalar EXPR\n            Forces EXPR to be interpreted in scalar context and\n            returns the value of EXPR.\n\n            There is no equivalent operator to force an expression\n            to be interpolated in list context because in practice,\n            this is never needed. If you really wanted to do so,\n            however, you could use the construction `@{[ (some\n            expression) ]}', but usually a simple `(some\n            expression)' suffices.\n\n            Since `scalar' is a unary operator, if you accidentally\n            use for EXPR a parenthesized list, this behaves as a\n            scalar comma expression, evaluating all but the last\n            element in void context and returning the final element\n            evaluated in scalar context. This is seldom what you\n            want.\n\n            The following single statement:\n\n                    print uc(scalar(&foo,$bar)),$baz;\n\n            is the moral equivalent of these two:\n\n                    &foo;\n                    print(uc($bar),$baz);\n\n            See the perlop manpage for more details on unary\n            operators and the comma operator.\n\n
seek=    seek FILEHANDLE,POSITION,WHENCE\n            Sets FILEHANDLE's position, just like the `fseek()' call\n            of `stdio()'. FILEHANDLE may be an expression whose\n            value gives the name of the filehandle. The values for\n            WHENCE are `0' to set the new position to POSITION, `1'\n            to set it to the current position plus POSITION, and `2'\n            to set it to EOF plus POSITION (typically negative). For\n            WHENCE you may use the constants `SEEK_SET', `SEEK_CUR',\n            and `SEEK_END' from either the `IO::Seekable' or the\n            POSIX module. Returns `1' upon success, `0' otherwise.\n            `syswrite()', don't use `seek()' -- buffering makes its\n            effect on the file's system position unpredictable and\n            non-portable. Use `sysseek()' instead.\n\n            Due to the rules and rigors of ANSI C, on some systems\n            you have to do a seek whenever you switch between\n            reading and writing. Amongst other things, this may have\n            the effect of calling stdio's clearerr(3). A WHENCE of\n            `1' (`SEEK_CUR') is useful for not moving the file\n            position:\n\n                seek(TEST,0,1);\n\n            This is also useful for applications emulating `tail -\n            f'. Once you hit EOF on your read, and then sleep for a\n            while, you might have to stick in a seek() to reset\n            things. The `seek()' doesn't change the current\n            position, but it *does* clear the end-of-file condition\n            on the handle, so that the next `<FILE>' makes Perl try\n            again to read something. We hope.\n\n            If that doesn't work (some stdios are particularly\n            cantankerous), then you may need something more like\n            this:\n\n                for (;;) {\n                    for ($curpos = tell(FILE); $_ = <FILE>;\n                         $curpos = tell(FILE)) {\n                        # search for some stuff and put it into files\n                    }\n                    sleep($for_a_while);\n                    seek(FILE, $curpos, 0);\n                }\n\n
seekdir=    seekdir DIRHANDLE,POS\n            Sets the current position for the `readdir()' routine on\n            DIRHANDLE. POS must be a value returned by `telldir()'.\n            Has the same caveats about possible directory compaction\n            as the corresponding system library routine.
select=    select FILEHANDLE\n    select  Returns the currently selected filehandle. Sets the current\n            default filehandle for output, if FILEHANDLE is\n            supplied. This has two effects: first, a `write()' or a\n            `print()' without a filehandle will default to this\n            FILEHANDLE. Second, references to variables related to\n            output will refer to this output channel. For example,\n            if you have to set the top of form format for more than\n            one output channel, you might do the following:\n                $^ = 'report1_top';\n                select(REPORT2);\n                $^ = 'report2_top';\n\n            FILEHANDLE may be an expression whose value gives the\n            name of the actual filehandle. Thus:\n\n                $oldfh = select(STDERR); $| = 1; select($oldfh);\n\n            Some programmers may prefer to think of filehandles as\n            objects with methods, preferring to write the last\n            example as:\n\n                use IO::Handle;\n                STDERR->autoflush(1);\n\n    select RBITS,WBITS,EBITS,TIMEOUT\n            This calls the select(2) system call with the bit masks\n            specified, which can be constructed using `fileno()' and\n            `vec()', along these lines:\n\n                $rin = $win = $ein = '';\n                vec($rin,fileno(STDIN),1) = 1;\n                vec($win,fileno(STDOUT),1) = 1;\n                $ein = $rin | $win;\n\n            If you want to select on many filehandles you might wish\n            to write a subroutine:\n\n                sub fhbits {\n                    my(@fhlist) = split(' ',$_[0]);\n                    my($bits);\n                    for (@fhlist) {\n                        vec($bits,fileno($_),1) = 1;\n                    }\n                    $bits;\n                }\n                $rin = fhbits('STDIN TTY SOCK');\n\n            The usual idiom is:\n\n                ($nfound,$timeleft) =\n                  select($rout=$rin, $wout=$win, $eout=$ein, $timeout);\n\n            or to block until something becomes ready just do this\n\n                $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);\n\n            Most systems do not bother to return anything useful in\n            `$timeleft', so calling select() in scalar context just\n            returns `$nfound'.\n\n            Any of the bit masks can also be undef. The timeout, if\n            specified, is in seconds, which may be fractional. Note:\n            not all implementations are capable of returning\n            the`$timeleft'. If not, they always return `$timeleft'\n            equal to the supplied `$timeout'.\n\n            You can effect a sleep of 250 milliseconds this way:\n\n                select(undef, undef, undef, 0.25);\n\n            WARNING: One should not attempt to mix buffered I/O\n            (like `read()' or <FH>) with `select()', except as\n            permitted by POSIX, and even then only on POSIX systems.\n            You have to use `sysread()' instead.\n\n
semctl=    semctl ID,SEMNUM,CMD,ARG\n            Calls the System V IPC function `semctl()'. You'll\n            probably have to say\n\n            first to get the correct constant definitions. If CMD is\n            IPC_STAT or GETALL, then ARG must be a variable which\n            will hold the returned semid_ds structure or semaphore\n            value array. Returns like `ioctl()': the undefined value\n            for error, "`0' but true" for zero, or the actual return\n            value otherwise. See also `IPC::SysV' and\n            `IPC::Semaphore' documentation.\n\n
semget=    semget KEY,NSEMS,FLAGS\n            Calls the System V IPC function semget. Returns the\n            semaphore id, or the undefined value if there is an\n            error. See also `IPC::SysV' and `IPC::SysV::Semaphore'\n            documentation.
semop=    semop KEY,OPSTRING\n            Calls the System V IPC function semop to perform\n            semaphore operations such as signaling and waiting.\n            OPSTRING must be a packed array of semop structures.\n            Each semop structure can be generated with `pack("sss",\n            $semnum, $semop, $semflag)'. The number of semaphore\n            operations is implied by the length of OPSTRING. Returns\n            TRUE if successful, or FALSE if there is an error. As an\n            example, the following code waits on semaphore `$semnum'\n            of semaphore id `$semid':\n                die "Semaphore trouble: $!\\n" unless semop($semid, $semop);\n\n            To signal the semaphore, replace `-1' with `1'. See also\n            `IPC::SysV' and `IPC::SysV::Semaphore' documentation.\n\n
send=    send SOCKET,MSG,FLAGS,TO\n    send SOCKET,MSG,FLAGS\n            Sends a message on a socket. Takes the same flags as the\n            system call of the same name. On unconnected sockets you\n            must specify a destination to send TO, in which case it\n            does a C `sendto()'. Returns the number of characters\n            sent, or the undefined value if there is an error. The C\n            system call sendmsg(2) is currently unimplemented. See\n            the section on "UDP: Message Passing" in the perlipc\n            manpage for examples.
setpgrp=    setpgrp PID,PGRP\n            Sets the current process group for the specified PID,\n            `0' for the current process. Will produce a fatal error\n            if used on a machine that doesn't implement setpgrp(2).\n            If the arguments are omitted, it defaults to `0,0'. Note\n            that the POSIX version of `setpgrp()' does not accept\n            any arguments, so only `setpgrp(0,0)' is portable. See\n            also `POSIX::setsid()'.
setpriority=    setpriority WHICH,WHO,PRIORITY\n            Sets the current priority for a process, a process\n            group, or a user. (See setpriority(2).) Will produce a\n            fatal error if used on a machine that doesn't implement\n            setpriority(2).
setsockopt=    setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL\n            Sets the socket option requested. Returns undefined if\n            there is an error. OPTVAL may be specified as `undef' if\n            you don't want to pass an argument.
shift=    shift ARRAY\n    shift   Shifts the first value of the array off and returns it,\n            shortening the array by 1 and moving everything down. If\n            there are no elements in the array, returns the\n            undefined value. If ARRAY is omitted, shifts the `@_'\n            array within the lexical scope of subroutines and\n            formats, and the `@ARGV' array at file scopes or within\n            the lexical scopes established by the `eval ''', `BEGIN\n            {}', `END {}', and `INIT {}' constructs. See also\n            `unshift()', `push()', and `pop()'. `Shift()' and\n            `unshift()' do the same thing to the left end of an\n            array that `pop()' and `push()' do to the right end.
shmctl=    shmctl ID,CMD,ARG\n            Calls the System V IPC function shmctl. You'll probably\n            have to say\n\n            first to get the correct constant definitions. If CMD is\n            `IPC_STAT', then ARG must be a variable which will hold\n            the returned `shmid_ds' structure. Returns like ioctl:\n            the undefined value for error, "`0' but true" for zero,\n            or the actual return value otherwise. See also\n            `IPC::SysV' documentation.\n\n
shmget=    shmget KEY,SIZE,FLAGS\n            Calls the System V IPC function shmget. Returns the\n            shared memory segment id, or the undefined value if\n            there is an error. See also `IPC::SysV' documentation.
shmread=    shmread ID,VAR,POS,SIZE\n    shmwrite ID,STRING,POS,SIZE\n            Reads or writes the System V shared memory segment ID\n            starting at position POS for size SIZE by attaching to\n            it, copying in/out, and detaching from it. When reading,\n            VAR must be a variable that will hold the data read.\n            When writing, if STRING is too long, only SIZE bytes are\n            used; if STRING is too short, nulls are written to fill\n            out SIZE bytes. Return TRUE if successful, or FALSE if\n            there is an error. See also `IPC::SysV' documentation\n            and the `IPC::Shareable' module from CPAN.
shmwrite=    shmwrite ID,STRING,POS,SIZE\n            Reads or writes the System V shared memory segment ID\n            starting at position POS for size SIZE by attaching to\n            it, copying in/out, and detaching from it. When reading,\n            VAR must be a variable that will hold the data read.\n            When writing, if STRING is too long, only SIZE bytes are\n            used; if STRING is too short, nulls are written to fill\n            out SIZE bytes. Return TRUE if successful, or FALSE if\n            there is an error. See also `IPC::SysV' documentation\n            and the `IPC::Shareable' module from CPAN.
shutdown=    shutdown SOCKET,HOW\n            Shuts down a socket connection in the manner indicated\n            by HOW, which has the same interpretation as in the\n            system call of the same name.\n                shutdown(SOCKET, 1);    # I/we have stopped writing data\n                shutdown(SOCKET, 2);    # I/we have stopped using this socket\n\n            This is useful with sockets when you want to tell the\n            other side you're done writing but not done reading, or\n            vice versa. It's also a more insistent form of close\n            because it also disables the filedescriptor in any\n            forked copies in other processes.\n\n
sin=    sin EXPR\n    sin     Returns the sine of EXPR (expressed in radians). If EXPR is\n            omitted, returns sine of `$_'.\n            `POSIX::asin()' function, or use this relation:\n\n                sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }\n\n
sleep=    sleep EXPR\n    sleep   Causes the script to sleep for EXPR seconds, or forever if\n            no EXPR. May be interrupted if the process receives a\n            signal such as `SIGALRM'. Returns the number of seconds\n            actually slept. You probably cannot mix `alarm()' and\n            `sleep()' calls, because `sleep()' is often implemented\n            using `alarm()'.\n            less than what you requested, depending on how it counts\n            seconds. Most modern systems always sleep the full\n            amount. They may appear to sleep longer than that,\n            however, because your process might not be scheduled\n            right away in a busy multitasking system.\n\n            For delays of finer granularity than one second, you may\n            use Perl's `syscall()' interface to access setitimer(2)\n            if your system supports it, or else see the select entry\n            elsewhere in this document above.\n\n            See also the POSIX module's `sigpause()' function.\n\n
socket=    socket SOCKET,DOMAIN,TYPE,PROTOCOL\n            Opens a socket of the specified kind and attaches it to\n            filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are\n            specified the same as for the system call of the same\n            name. You should "`use Socket;'" first to get the proper\n            definitions imported. See the examples in the section on\n            "Sockets: Client/Server Communication" in the perlipc\n            manpage.
socketpair=    socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL\n            Creates an unnamed pair of sockets in the specified\n            domain, of the specified type. DOMAIN, TYPE, and\n            PROTOCOL are specified the same as for the system call\n            of the same name. If unimplemented, yields a fatal\n            error. Returns TRUE if successful.\n            `socketpair()', in which a call to `pipe(Rdr, Wtr)' is\n            essentially:\n\n                use Socket;\n                socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);\n                shutdown(Rdr, 1);        # no more writing for reader\n                shutdown(Wtr, 0);        # no more reading for writer\n\n            See the perlipc manpage for an example of socketpair\n            use.\n\n
sort=    sort SUBNAME LIST\n    sort BLOCK LIST\n    sort LIST\n            Sorts the LIST and returns the sorted list value. If\n            SUBNAME or BLOCK is omitted, `sort()'s in standard\n            string comparison order. If SUBNAME is specified, it\n            gives the name of a subroutine that returns an integer\n            less than, equal to, or greater than `0', depending on\n            how the elements of the array are to be ordered. (The\n            `<=>' and `cmp' operators are extremely useful in such\n            routines.) SUBNAME may be a scalar variable name\n            (unsubscripted), in which case the value provides the\n            name of (or a reference to) the actual subroutine to\n            use. In place of a SUBNAME, you can provide a BLOCK as\n            an anonymous, in-line sort subroutine.\n            for subroutines is bypassed, with the following effects:\n            the subroutine may not be a recursive subroutine, and\n            the two elements to be compared are passed into the\n            subroutine not via `@_' but as the package global\n            variables `$a' and `$b' (see example below). They are\n            passed by reference, so don't modify `$a' and `$b'. And\n            don't try to declare them as lexicals either.\n\n            You also cannot exit out of the sort block or subroutine\n            using any of the loop control operators described in the\n            perlsyn manpage or with `goto()'.\n\n            When `use locale' is in effect, `sort LIST' sorts LIST\n            according to the current collation locale. See the\n            perllocale manpage.\n\n            Examples:\n\n                # sort lexically\n                @articles = sort @files;\n\n                # same thing, but with explicit sort routine\n                @articles = sort {$a cmp $b} @files;\n\n                # now case-insensitively\n                @articles = sort {uc($a) cmp uc($b)} @files;\n\n                # same thing in reversed order\n                @articles = sort {$b cmp $a} @files;\n\n                # sort numerically ascending\n                @articles = sort {$a <=> $b} @files;\n\n                # sort numerically descending\n                @articles = sort {$b <=> $a} @files;\n\n                # sort using explicit subroutine name\n                sub byage {\n                    $age{$a} <=> $age{$b};  # presuming numeric\n                }\n                @sortedclass = sort byage @class;\n\n                # this sorts the %age hash by value instead of key\n                # using an in-line function\n                @eldest = sort { $age{$b} <=> $age{$a} } keys %age;\n\n                sub backwards { $b cmp $a; }\n                @harry = ('dog','cat','x','Cain','Abel');\n                @george = ('gone','chased','yz','Punished','Axed');\n                print sort @harry;\n                        # prints AbelCaincatdogx\n                print sort backwards @harry;\n                        # prints xdogcatCainAbel\n                print sort @george, 'to', @harry;\n                        # prints AbelAxedCainPunishedcatchaseddoggonetoxyz\n\n                # inefficiently sort by descending numeric compare using\n                # the first integer after the first = sign, or the\n                # whole record case-insensitively otherwise\n\n                @new = sort {\n                    ($b =~ /=(\\d+)/)[0] <=> ($a =~ /=(\\d+)/)[0]\n                                        ||\n                                uc($a)  cmp  uc($b)\n                } @old;\n\n                # same thing, but much more efficiently;\n                # we'll build auxiliary indices instead\n                # for speed\n                @nums = @caps = ();\n                for (@old) {\n                    push @nums, /=(\\d+)/;\n                    push @caps, uc($_);\n                }\n\n                @new = @old[ sort {\n                                    $nums[$b] <=> $nums[$a]\n                                             ||\n                                    $caps[$a] cmp $caps[$b]\n                                   } 0..$#old\n                           ];\n\n                # same thing using a Schwartzian Transform (no temps)\n                @new = map { $_->[0] }\n                    sort { $b->[1] <=> $a->[1]\n                                    ||\n                           $a->[2] cmp $b->[2]\n                    } map { [$_, /=(\\d+)/, uc($_)] } @old;\n\n            If you're using strict, you *MUST NOT* declare `$a' and\n            `$b' as lexicals. They are package globals. That means\n            if you're in the `main' package, it's\n\n                @articles = sort {$main::b <=> $main::a} @files;\n\n            or just\n\n                @articles = sort {$::b <=> $::a} @files;\n\n            but if you're in the `FooPack' package, it's\n\n                @articles = sort {$FooPack::b <=> $FooPack::a} @files;\n\n            The comparison function is required to behave. If it\n            returns inconsistent results (sometimes saying `$x[1]'\n            is less than `$x[2]' and sometimes saying the opposite,\n            for example) the results are not well-defined.\n\n
splice=    splice ARRAY,OFFSET,LENGTH,LIST\n    splice ARRAY,OFFSET,LENGTH\n    splice ARRAY,OFFSET\n            Removes the elements designated by OFFSET and LENGTH\n            from an array, and replaces them with the elements of\n            LIST, if any. In list context, returns the elements\n            removed from the array. In scalar context, returns the\n            last element removed, or `undef' if no elements are\n            removed. The array grows or shrinks as necessary. If\n            OFFSET is negative then it start that far from the end\n            of the array. If LENGTH is omitted, removes everything\n            from OFFSET onward. If LENGTH is negative, leave that\n            many elements off the end of the array. The following\n            equivalences hold (assuming `$[ == 0'):\n                pop(@a)             splice(@a,-1)\n                shift(@a)           splice(@a,0,1)\n                unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)\n                $a[$x] = $y         splice(@a,$x,1,$y)\n\n            Example, assuming array lengths are passed before\n            arrays:\n\n                sub aeq {   # compare two list values\n                    my(@a) = splice(@_,0,shift);\n                    my(@b) = splice(@_,0,shift);\n                    return 0 unless @a == @b;       # same len?\n                    while (@a) {\n                        return 0 if pop(@a) ne pop(@b);\n                    }\n                    return 1;\n                }\n                if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }\n\n
sprintf=    sprintf FORMAT, LIST\n            Returns a string formatted by the usual `printf()'\n            conventions of the C library function `sprintf()'. See\n            the sprintf(3) manpage or the printf(3) manpage on your\n            system for an explanation of the general principles.\n            the C function `sprintf()', but it doesn't use it\n            (except for floating-point numbers, and even then only\n            the standard modifiers are allowed). As a result, any\n            non-standard extensions in your local `sprintf()' are\n            not available from Perl.\n\n            Perl's `sprintf()' permits the following universally-\n            known conversions:\n\n               %%   a percent sign\n               %c   a character with the given number\n               %s   a string\n               %d   a signed integer, in decimal\n               %u   an unsigned integer, in decimal\n               %o   an unsigned integer, in octal\n               %x   an unsigned integer, in hexadecimal\n               %e   a floating-point number, in scientific notation\n               %f   a floating-point number, in fixed decimal notation\n               %g   a floating-point number, in %e or %f notation\n\n            In addition, Perl permits the following widely-supported\n            conversions:\n\n               %X   like %x, but using upper-case letters\n               %E   like %e, but using an upper-case "E"\n               %G   like %g, but with an upper-case "E" (if applicable)\n               %p   a pointer (outputs the Perl value's address in hexadecimal)\n               %n   special: *stores* the number of characters output so far\n                    into the next variable in the parameter list \n\n            Finally, for backward (and we do mean "backward")\n            compatibility, Perl permits these unnecessary but\n            widely-supported conversions:\n\n               %i   a synonym for %d\n               %D   a synonym for %ld\n               %U   a synonym for %lu\n               %O   a synonym for %lo\n               %F   a synonym for %f\n\n            Perl permits the following universally-known flags\n            between the `%' and the conversion letter:\n\n               space   prefix positive number with a space\n               +       prefix positive number with a plus sign\n               -       left-justify within the field\n               0       use zeros, not spaces, to right-justify\n               #       prefix non-zero octal with "0", non-zero hex with "0x"\n               number  minimum field width\n               .number "precision": digits after decimal point for\n                       floating-point, max length for string, minimum length\n                       for integer\n               l       interpret integer as C type "long" or "unsigned long"\n               h       interpret integer as C type "short" or "unsigned short"\n\n            There is also one Perl-specific flag:\n\n               V       interpret integer as Perl's standard integer type\n\n            Where a number would appear in the flags, an asterisk\n            ("`*'") may be used instead, in which case Perl uses the\n            next item in the parameter list as the given number\n            (that is, as the field width or precision). If a field\n            width obtained through "`*'" is negative, it has the\n            same effect as the "`-'" flag: left-justification.\n\n            If `use locale' is in effect, the character used for the\n            decimal point in formatted real numbers is affected by\n            the LC_NUMERIC locale. See the perllocale manpage.\n\n
sqrt=    sqrt EXPR\n    sqrt    Return the square root of EXPR. If EXPR is omitted, returns\n            square root of `$_'. Only works on non-negative\n            operands, unless you've loaded the standard\n            Math::Complex module.\n                print sqrt(-2);    # prints 1.4142135623731i\n\n
srand=    srand EXPR\n    srand   Sets the random number seed for the `rand()' operator. If\n            EXPR is omitted, uses a semi-random value supplied by\n            the kernel (if it supports the /dev/urandom device) or\n            based on the current time and process ID, among other\n            things. In versions of Perl prior to 5.004 the default\n            seed was just the current `time()'. This isn't a\n            particularly good seed, so many old programs supply\n            their own seed value (often `time ^ $$' or `time ^ ($$ +\n            ($$ << 15))'), but that isn't necessary any more.\n            all, because if it is not called explicitly, it is\n            called implicitly at the first use of the `rand()'\n            operator. However, this was not the case in version of\n            Perl before 5.004, so if your script will run under\n            older Perl versions, it should call `srand()'.\n\n            Note that you need something much more random than the\n            default seed for cryptographic purposes. Checksumming\n            the compressed output of one or more rapidly changing\n            operating system status programs is the usual method.\n            For example:\n\n                srand (time ^ $$ ^ unpack "%L*", `ps axww | gzip`);\n\n            If you're particularly concerned with this, see the\n            `Math::TrulyRandom' module in CPAN.\n\n            Do *not* call `srand()' multiple times in your program\n            unless you know exactly what you're doing and why you're\n            doing it. The point of the function is to "seed" the\n            `rand()' function so that `rand()' can produce a\n            different sequence each time you run your program. Just\n            do it once at the top of your program, or you *won't*\n            get random numbers out of `rand()'!\n\n            Frequently called programs (like CGI scripts) that\n            simply use\n\n                time ^ $$\n\n            for a seed can fall prey to the mathematical property\n            that\n\n                a^b == (a+1)^(b+1)\n\n            one-third of the time. So don't do that.\n\n
stat=    stat FILEHANDLE\n    stat EXPR\n    stat    Returns a 13-element list giving the status info for a file,\n            either the file opened via FILEHANDLE, or named by EXPR.\n            If EXPR is omitted, it stats `$_'. Returns a null list\n            if the stat fails. Typically used as follows:\n                   $atime,$mtime,$ctime,$blksize,$blocks)\n                       = stat($filename);\n\n            Not all fields are supported on all filesystem types.\n            Here are the meaning of the fields:\n\n              0 dev      device number of filesystem\n              1 ino      inode number\n              2 mode     file mode  (type and permissions)\n              3 nlink    number of (hard) links to the file\n              4 uid      numeric user ID of file's owner\n              5 gid      numeric group ID of file's owner\n              6 rdev     the device identifier (special files only)\n              7 size     total size of file, in bytes\n              8 atime    last access time since the epoch\n              9 mtime    last modify time since the epoch\n             10 ctime    inode change time (NOT creation time!) since the epoch\n             11 blksize  preferred block size for file system I/O\n             12 blocks   actual number of blocks allocated\n\n            (The epoch was at 00:00 January 1, 1970 GMT.)\n\n            If stat is passed the special filehandle consisting of\n            an underline, no stat is done, but the current contents\n            of the stat structure from the last stat or filetest are\n            returned. Example:\n\n                if (-x $file && (($d) = stat(_)) && $d < 0) {\n                    print "$file is executable NFS file\\n";\n                }\n\n            (This works on machines only for which the device number\n            is negative under NFS.)\n\n            Because the mode contains both the file type and its\n            permissions, you should mask off the file type portion\n            and (s)printf using a `"%o"' if you want to see the real\n            permissions.\n\n                $mode = (stat($filename))[2];\n                printf "Permissions are %04o\\n", $mode & 07777;\n\n            In scalar context, `stat()' returns a boolean value\n            indicating success or failure, and, if successful, sets\n            the information associated with the special filehandle\n            `_'.\n\n            The File::stat module provides a convenient, by-name\n            access mechanism:\n\n                use File::stat;\n                $sb = stat($filename);\n                printf "File is %s, size is %s, perm %04o, mtime %s\\n", \n                    $filename, $sb->size, $sb->mode & 07777,\n                    scalar localtime $sb->mtime;\n\n
study=    study SCALAR\n    study   Takes extra time to study SCALAR (`$_' if unspecified) in\n            anticipation of doing many pattern matches on the string\n            before it is next modified. This may or may not save\n            time, depending on the nature and number of patterns you\n            are searching on, and on the distribution of character\n            frequencies in the string to be searched -- you probably\n            want to compare run times with and without it to see\n            which runs faster. Those loops which scan for many short\n            constant strings (including the constant parts of more\n            complex patterns) will benefit most. You may have only\n            one `study()' active at a time -- if you study a\n            different scalar the first is "unstudied". (The way\n            `study()' works is this: a linked list of every\n            character in the string to be searched is made, so we\n            know, for example, where all the `'k'' characters are.\n            From each search string, the rarest character is\n            selected, based on some static frequency tables\n            constructed from some C programs and English text. Only\n            those places that contain this "rarest" character are\n            examined.)\n            entries before any line containing a certain pattern:\n\n                while (<>) {\n                    study;\n                    print ".IX foo\\n"       if /\\bfoo\\b/;\n                    print ".IX bar\\n"       if /\\bbar\\b/;\n                    print ".IX blurfl\\n"    if /\\bblurfl\\b/;\n                    # ...\n                    print;\n                }\n\n            In searching for `/\\bfoo\\b/', only those locations in\n            `$_' that contain `"f"' will be looked at, because `"f"'\n            is rarer than `"o"'. In general, this is a big win\n            except in pathological cases. The only question is\n            whether it saves you more time than it took to build the\n            linked list in the first place.\n\n            Note that if you have to look for strings that you don't\n            know till runtime, you can build an entire loop as a\n            string and `eval()' that to avoid recompiling all your\n            patterns all the time. Together with undefining `$/' to\n            input entire files as one record, this can be very fast,\n            often faster than specialized programs like fgrep(1).\n            The following scans a list of files (`@files') for a\n            list of words (`@words'), and prints out the names of\n            those files that contain a match:\n\n                $search = 'while (<>) { study;';\n                foreach $word (@words) {\n                    $search .= "++\\$seen{\\$ARGV} if /\\\\b$word\\\\b/;\\n";\n                }\n                $search .= "}";\n                @ARGV = @files;\n                undef $/;\n                eval $search;               # this screams\n                $/ = "\\n";          # put back to normal input delimiter\n                foreach $file (sort keys(%seen)) {\n                    print $file, "\\n";\n                }\n\n
substr=    substr EXPR,OFFSET,LEN,REPLACEMENT\n    substr EXPR,OFFSET,LEN\n    substr EXPR,OFFSET\n            Extracts a substring out of EXPR and returns it. First\n            character is at offset `0', or whatever you've set `$['\n            to (but don't do that). If OFFSET is negative (or more\n            precisely, less than `$['), starts that far from the end\n            of the string. If LEN is omitted, returns everything to\n            the end of the string. If LEN is negative, leaves that\n            many characters off the end of the string.\n            string, the part within the string is returned. If the\n            substring is totally outside the string a warning is\n            produced.\n\n            You can use the substr() function as an lvalue, in which\n            case EXPR must itself be an lvalue. If you assign\n            something shorter than LEN, the string will shrink, and\n            if you assign something longer than LEN, the string will\n            grow to accommodate it. To keep the string the same\n            length you may need to pad or chop your value using\n            `sprintf()'.\n\n            An alternative to using substr() as an lvalue is to\n            specify the replacement string as the 4th argument. This\n            allows you to replace parts of the EXPR and return what\n            was there before in one operation, just as you can with\n            splice().\n\n
symlink=    symlink OLDFILE,NEWFILE\n            Creates a new filename symbolically linked to the old\n            filename. Returns `1' for success, `0' otherwise. On\n            systems that don't support symbolic links, produces a\n            fatal error at run time. To check for that, use eval:\n\n
syscall=    syscall LIST\n            Calls the system call specified as the first element of\n            the list, passing the remaining elements as arguments to\n            the system call. If unimplemented, produces a fatal\n            error. The arguments are interpreted as follows: if a\n            given argument is numeric, the argument is passed as an\n            int. If not, the pointer to the string value is passed.\n            You are responsible to make sure a string is pre-\n            extended long enough to receive any result that might be\n            written into a string. You can't use a string literal\n            (or other read-only string) as an argument to\n            `syscall()' because Perl has to assume that any string\n            pointer might be written through. If your integer\n            arguments are not literals and have never been\n            interpreted in a numeric context, you may need to add\n            `0' to them to force them to look like numbers. This\n            emulates the `syswrite()' function (or vice versa):\n                $s = "hi there\\n";\n                syscall(&SYS_write, fileno(STDOUT), $s, length $s);\n\n            Note that Perl supports passing of up to only 14\n            arguments to your system call, which in practice should\n            usually suffice.\n\n            Syscall returns whatever value returned by the system\n            call it calls. If the system call fails, `syscall()'\n            returns `-1' and sets `$!' (errno). Note that some\n            system calls can legitimately return `-1'. The proper\n            way to handle such calls is to assign `$!=0;' before the\n            call and check the value of `$!' if syscall returns `-\n            1'.\n\n            There's a problem with `syscall(&SYS_pipe)': it returns\n            the file number of the read end of the pipe it creates.\n            There is no way to retrieve the file number of the other\n            end. You can avoid this problem by using `pipe()'\n            instead.\n\n
sysopen=    sysopen FILEHANDLE,FILENAME,MODE\n    sysopen FILEHANDLE,FILENAME,MODE,PERMS\n            Opens the file whose filename is given by FILENAME, and\n            associates it with FILEHANDLE. If FILEHANDLE is an\n            expression, its value is used as the name of the real\n            filehandle wanted. This function calls the underlying\n            operating system's `open()' function with the parameters\n            FILENAME, MODE, PERMS.\n            are system-dependent; they are available via the\n            standard module `Fcntl'. For historical reasons, some\n            values work on almost every system supported by perl:\n            zero means read-only, one means write-only, and two\n            means read/write. We know that these values do *not*\n            work under OS/390 & VM/ESA Unix and on the Macintosh;\n            you probably don't want to use them in new code.\n\n            If the file named by FILENAME does not exist and the\n            `open()' call creates it (typically because MODE\n            includes the `O_CREAT' flag), then the value of PERMS\n            specifies the permissions of the newly created file. If\n            you omit the PERMS argument to `sysopen()', Perl uses\n            the octal value `0666'. These permission values need to\n            be in octal, and are modified by your process's current\n            `umask'.\n\n            You should seldom if ever use `0644' as argument to\n            `sysopen()', because that takes away the user's option\n            to have a more permissive umask. Better to omit it. See\n            the perlfunc(1) entry on `umask' for more on this.\n\n            See the perlopentut manpage for a kinder, gentler\n            explanation of opening files.\n\n
sysread=    sysread FILEHANDLE,SCALAR,LENGTH,OFFSET\n    sysread FILEHANDLE,SCALAR,LENGTH\n            Attempts to read LENGTH bytes of data into variable\n            SCALAR from the specified FILEHANDLE, using the system\n            call read(2). It bypasses stdio, so mixing this with\n            other kinds of reads, `print()', `write()', `seek()',\n            `tell()', or `eof()' can cause confusion because stdio\n            usually buffers data. Returns the number of bytes\n            actually read, `0' at end of file, or undef if there was\n            an error. SCALAR will be grown or shrunk so that the\n            last byte actually read is the last byte of the scalar\n            after the read.\n            some place in the string other than the beginning. A\n            negative OFFSET specifies placement at that many bytes\n            counting backwards from the end of the string. A\n            positive OFFSET greater than the length of SCALAR\n            results in the string being padded to the required size\n            with `"\\0"' bytes before the result of the read is\n            appended.\n\n            There is no syseof() function, which is ok, since eof()\n            doesn't work very well on device files (like ttys)\n            anyway. Use sysread() and check for a return value for 0\n            to decide whether you're done.\n\n
sysseek=    sysseek FILEHANDLE,POSITION,WHENCE\n            Sets FILEHANDLE's system position using the system call\n            lseek(2). It bypasses stdio, so mixing this with reads\n            (other than `sysread()'), `print()', `write()',\n            `seek()', `tell()', or `eof()' may cause confusion.\n            FILEHANDLE may be an expression whose value gives the\n            name of the filehandle. The values for WHENCE are `0' to\n            set the new position to POSITION, `1' to set the it to\n            the current position plus POSITION, and `2' to set it to\n            EOF plus POSITION (typically negative). For WHENCE, you\n            may use the constants `SEEK_SET', `SEEK_CUR', and\n            `SEEK_END' from either the `IO::Seekable' or the POSIX\n            module.\n            failure. A position of zero is returned as the string\n            "`0' but true"; thus `sysseek()' returns TRUE on success\n            and FALSE on failure, yet you can still easily determine\n            the new position.\n\n
system=    system LIST\n    system PROGRAM LIST\n            Does exactly the same thing as "`exec LIST'", except\n            that a fork is done first, and the parent process waits\n            for the child process to complete. Note that argument\n            processing varies depending on the number of arguments.\n            If there is more than one argument in LIST, or if LIST\n            is an array with more than one value, starts the program\n            given by the first element of the list with arguments\n            given by the rest of the list. If there is only one\n            scalar argument, the argument is checked for shell\n            metacharacters, and if there are any, the entire\n            argument is passed to the system's command shell for\n            parsing (this is `/bin/sh -c' on Unix platforms, but\n            varies on other platforms). If there are no shell\n            metacharacters in the argument, it is split into words\n            and passed directly to `execvp()', which is more\n            efficient.\n            returned by the `wait()' call. To get the actual exit\n            value divide by 256. See also the exec entry elsewhere\n            in this document . This is *NOT* what you want to use to\n            capture the output from a command, for that you should\n            use merely backticks or `qx//', as described in the\n            section on "`STRING`" in the perlop manpage.\n\n            Like `exec()', `system()' allows you to lie to a program\n            about its name if you use the "`system PROGRAM LIST'"\n            syntax. Again, see the exec entry elsewhere in this\n            document .\n\n            Because `system()' and backticks block `SIGINT' and\n            `SIGQUIT', killing the program they're running doesn't\n            actually interrupt your program.\n\n                @args = ("command", "arg1", "arg2");\n                system(@args) == 0\n                     or die "system @args failed: $?"\n\n            You can check all the failure possibilities by\n            inspecting `$?' like this:\n\n                $exit_value  = $? >> 8;\n                $signal_num  = $? & 127;\n                $dumped_core = $? & 128;\n\n            When the arguments get executed via the system shell,\n            results and return codes will be subject to its quirks\n            and capabilities. See the section on "`STRING`" in the\n            perlop manpage and the exec entry elsewhere in this\n            document for details.\n\n
syswrite=    syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET\n    syswrite FILEHANDLE,SCALAR,LENGTH\n    syswrite FILEHANDLE,SCALAR\n            Attempts to write LENGTH bytes of data from variable\n            SCALAR to the specified FILEHANDLE, using the system\n            call write(2). If LENGTH is not specified, writes whole\n            SCALAR. It bypasses stdio, so mixing this with reads\n            (other than `sysread())', `print()', `write()',\n            `seek()', `tell()', or `eof()' may cause confusion\n            because stdio usually buffers data. Returns the number\n            of bytes actually written, or `undef' if there was an\n            error. If the LENGTH is greater than the available data\n            in the SCALAR after the OFFSET, only as much data as is\n            available will be written.\n            part of the string other than the beginning. A negative\n            OFFSET specifies writing that many bytes counting\n            backwards from the end of the string. In the case the\n            SCALAR is empty you can use OFFSET but only zero offset.\n\n
tell=    tell FILEHANDLE\n    tell    Returns the current position for FILEHANDLE. FILEHANDLE may\n            be an expression whose value gives the name of the\n            actual filehandle. If FILEHANDLE is omitted, assumes the\n            file last read.\n            1)' for that.\n\n
telldir=    telldir DIRHANDLE\n            Returns the current position of the `readdir()' routines\n            on DIRHANDLE. Value may be given to `seekdir()' to\n            access a particular location in a directory. Has the\n            same caveats about possible directory compaction as the\n            corresponding system library routine.
tie=    tie VARIABLE,CLASSNAME,LIST\n            This function binds a variable to a package class that\n            will provide the implementation for the variable.\n            VARIABLE is the name of the variable to be enchanted.\n            CLASSNAME is the name of a class implementing objects of\n            correct type. Any additional arguments are passed to the\n            "`new()'" method of the class (meaning `TIESCALAR',\n            `TIEHANDLE', `TIEARRAY', or `TIEHASH'). Typically these\n            are arguments such as might be passed to the\n            `dbm_open()' function of C. The object returned by the\n            "`new()'" method is also returned by the `tie()'\n            function, which would be useful if you want to access\n            other methods in CLASSNAME.\n            return huge lists when used on large objects, like DBM\n            files. You may prefer to use the `each()' function to\n            iterate over such. Example:\n\n                # print out history file offsets\n                use NDBM_File;\n                tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);\n                while (($key,$val) = each %HIST) {\n                    print $key, ' = ', unpack('L',$val), "\\n";\n                }\n                untie(%HIST);\n\n            A class implementing a hash should have the following\n            methods:\n\n                TIEHASH classname, LIST\n                FETCH this, key\n                STORE this, key, value\n                DELETE this, key\n                CLEAR this\n                EXISTS this, key\n                FIRSTKEY this\n                NEXTKEY this, lastkey\n                DESTROY this\n\n            A class implementing an ordinary array should have the\n            following methods:\n\n                TIEARRAY classname, LIST\n                FETCH this, key\n                STORE this, key, value\n                FETCHSIZE this\n                STORESIZE this, count\n                CLEAR this\n                PUSH this, LIST\n                POP this\n                SHIFT this\n                UNSHIFT this, LIST\n                SPLICE this, offset, length, LIST\n                EXTEND this, count\n                DESTROY this\n\n            A class implementing a file handle should have the\n            following methods:\n\n                TIEHANDLE classname, LIST\n                READ this, scalar, length, offset\n                READLINE this\n                GETC this\n                WRITE this, scalar, length, offset\n                PRINT this, LIST\n                PRINTF this, format, LIST\n                CLOSE this\n                DESTROY this\n\n            A class implementing a scalar should have the following\n            methods:\n\n                TIESCALAR classname, LIST\n                FETCH this,\n                STORE this, value\n                DESTROY this\n\n            Not all methods indicated above need be implemented. See\n            the perltie manpage, the Tie::Hash manpage, the\n            Tie::Array manpage, the Tie::Scalar manpage, and the\n            Tie::Handle manpage.\n\n            Unlike `dbmopen()', the `tie()' function will not use or\n            require a module for you--you need to do that explicitly\n            yourself. See the DB_File manpage or the Config module\n            for interesting `tie()' implementations.\n\n            For further details see the perltie manpage, the section\n            on "tied VARIABLE".\n\n
time=    time    Returns the number of non-leap seconds since whatever time\n            the system considers to be the epoch (that's 00:00:00,\n            January 1, 1904 for MacOS, and 00:00:00 UTC, January 1,\n            1970 for most other systems). Suitable for feeding to\n            `gmtime()' and `localtime()'.
times=    times   Returns a four-element list giving the user and system\n            times, in seconds, for this process and the children of\n            this process.\n\n
tr=    tr///   The transliteration operator. Same as `y///'. See the perlop\n            manpage.
truncate=    truncate FILEHANDLE,LENGTH\n    truncate EXPR,LENGTH\n            Truncates the file opened on FILEHANDLE, or named by\n            EXPR, to the specified length. Produces a fatal error if\n            truncate isn't implemented on your system. Returns TRUE\n            if successful, the undefined value otherwise.
uc=    uc EXPR\n    uc      Returns an uppercased version of EXPR. This is the internal\n            function implementing the `\\U' escape in double-quoted\n            strings. Respects current LC_CTYPE locale if `use\n            locale' in force. See the perllocale manpage. (It does\n            not attempt to do titlecase mapping on initial letters.\n            See `ucfirst()' for that.)\n\n
ucfirst=    ucfirst EXPR\n    ucfirst Returns the value of EXPR with the first character in\n            uppercase. This is the internal function implementing\n            the `\\u' escape in double-quoted strings. Respects\n            current LC_CTYPE locale if `use locale' in force. See\n            the perllocale manpage.\n\n
umask=    umask EXPR\n    umask   Sets the umask for the process to EXPR and returns the\n            previous value. If EXPR is omitted, merely returns the\n            current umask.\n            sets of three bits, or three octal digits: `0750' (the\n            leading 0 indicates octal and isn't one of the digits).\n            The `umask' value is such a number representing disabled\n            permissions bits. The permission (or "mode") values you\n            pass `mkdir' or `sysopen' are modified by your umask, so\n            even if you tell `sysopen' to create a file with\n            permissions `0777', if your umask is `0022' then the\n            file will actually be created with permissions `0755'.\n            If your `umask' were `0027' (group can't write; others\n            can't read, write, or execute), then passing `sysopen()'\n            `0666' would create a file with mode `0640' (`0666 &~\n            027' is `0640').\n\n            Here's some advice: supply a creation mode of `0666' for\n            regular files (in `sysopen()') and one of `0777' for\n            directories (in `mkdir()') and executable files. This\n            gives users the freedom of choice: if they want\n            protected files, they might choose process umasks of\n            `022', `027', or even the particularly antisocial mask\n            of `077'. Programs should rarely if ever make policy\n            decisions better left to the user. The exception to this\n            is when writing files that should be kept private: mail\n            files, web browser cookies, *.rhosts* files, and so on.\n\n            If umask(2) is not implemented on your system and you\n            are trying to restrict access for *yourself* (i.e.,\n            (EXPR & 0700) > 0), produces a fatal error at run time.\n            If umask(2) is not implemented and you are not trying to\n            restrict access for yourself, returns `undef'.\n\n            Remember that a umask is a number, usually given in\n            octal; it is *not* a string of octal digits. See also\n            the oct entry elsewhere in this document if all you have\n            is a string.\n\n
undef=    undef EXPR\n    undef   Undefines the value of EXPR, which must be an lvalue. Use\n            only on a scalar value, an array (using "`@'"), a hash\n            (using "`%'"), a subroutine (using "`&'"), or a typeglob\n            (using "<*>"). (Saying `undef $hash{$key}' will probably\n            not do what you expect on most predefined variables or\n            DBM list values, so don't do that; see the delete\n            manpage.) Always returns the undefined value. You can\n            omit the EXPR, in which case nothing is undefined, but\n            you still get an undefined value that you could, for\n            instance, return from a subroutine, assign to a variable\n            or pass as a parameter. Examples:\n                undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};\n                undef @ary;\n                undef %hash;\n                undef &mysub;\n                undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.\n                return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;\n                select undef, undef, undef, 0.25;\n                ($a, $b, undef, $c) = &foo;       # Ignore third value returned\n\n            Note that this is a unary operator, not a list operator.\n\n
unlink=    unlink LIST\n    unlink  Deletes a list of files. Returns the number of files\n            successfully deleted.\n                unlink @goners;\n                unlink <*.bak>;\n\n            Note: `unlink()' will not delete directories unless you\n            are superuser and the -U flag is supplied to Perl. Even\n            if these conditions are met, be warned that unlinking a\n            directory can inflict damage on your filesystem. Use\n            `rmdir()' instead.\n\n            If LIST is omitted, uses `$_'.\n\n
unpack=    unpack TEMPLATE,EXPR\n            `Unpack()' does the reverse of `pack()': it takes a\n            string representing a structure and expands it out into\n            a list value, returning the array value. (In scalar\n            context, it returns merely the first value produced.)\n            The TEMPLATE has the same format as in the `pack()'\n            function. Here's a subroutine that does substring:\n                    my($what,$where,$howmuch) = @_;\n                    unpack("x$where a$howmuch", $what);\n                }\n\n            and then there's\n\n                sub ordinal { unpack("c",$_[0]); } # same as ord()\n\n            In addition, you may prefix a field with a %<number> to\n            indicate that you want a <number>-bit checksum of the\n            items instead of the items themselves. Default is a 16-\n            bit checksum. For example, the following computes the\n            same number as the System V sum program:\n\n                while (<>) {\n                    $checksum += unpack("%32C*", $_);\n                }\n                $checksum %= 65535;\n\n            The following efficiently counts the number of set bits\n            in a bit vector:\n\n                $setbits = unpack("%32b*", $selectmask);\n\n            See the pack entry elsewhere in this document for more\n            examples.\n\n
unshift=    unshift ARRAY,LIST\n            Does the opposite of a `shift()'. Or the opposite of a\n            `push()', depending on how you look at it. Prepends list\n            to the front of the array, and returns the new number of\n            elements in the array.\n\n            Note the LIST is prepended whole, not one element at a\n            time, so the prepended elements stay in the same order.\n            Use `reverse()' to do the reverse.\n\n
untie=    untie VARIABLE\n            Breaks the binding between a variable and a package.\n            (See `tie()'.)
use=    use Module LIST\n    use Module\n    use Module VERSION LIST\n    use VERSION\n            Imports some semantics into the current package from the\n            named module, generally by aliasing certain subroutine\n            or variable names into your package. It is exactly\n            equivalent to\n\n            except that Module *must* be a bareword.\n\n            If the first argument to `use' is a number, it is\n            treated as a version number instead of a module name. If\n            the version of the Perl interpreter is less than\n            VERSION, then an error message is printed and Perl exits\n            immediately. This is often useful if you need to check\n            the current Perl version before `use'ing library modules\n            that have changed in incompatible ways from older\n            versions of Perl. (We try not to do this more than we\n            have to.)\n\n            The `BEGIN' forces the `require' and `import()' to\n            happen at compile time. The `require' makes sure the\n            module is loaded into memory if it hasn't been yet. The\n            `import()' is not a builtin--it's just an ordinary\n            static method call into the "`Module'" package to tell\n            the module to import the list of features back into the\n            current package. The module can implement its `import()'\n            method any way it likes, though most modules just choose\n            to derive their `import()' method via inheritance from\n            the `Exporter' class that is defined in the `Exporter'\n            module. See the Exporter manpage. If no `import()'\n            method can be found then the error is currently silently\n            ignored. This may change to a fatal error in a future\n            version.\n\n            If you don't want your namespace altered, explicitly\n            supply an empty list:\n\n                use Module ();\n\n            That is exactly equivalent to\n\n                BEGIN { require Module }\n\n            If the VERSION argument is present between Module and\n            LIST, then the `use' will call the VERSION method in\n            class Module with the given version as an argument. The\n            default VERSION method, inherited from the Universal\n            class, croaks if the given version is larger than the\n            value of the variable `$Module::VERSION'. (Note that\n            there is not a comma after VERSION!)\n\n            Because this is a wide-open interface, pragmas (compiler\n            directives) are also implemented this way. Currently\n            implemented pragmas are:\n\n                use integer;\n                use diagnostics;\n                use sigtrap qw(SEGV BUS);\n                use strict  qw(subs vars refs);\n                use subs    qw(afunc blurfl);\n\n            Some of these these pseudo-modules import semantics into\n            the current block scope (like `strict' or `integer',\n            unlike ordinary modules, which import symbols into the\n            current package (which are effective through the end of\n            the file).\n\n            There's a corresponding "`no'" command that unimports\n            meanings imported by `use', i.e., it calls `unimport\n            Module LIST' instead of `import()'.\n\n                no integer;\n                no strict 'refs';\n\n            If no `unimport()' method can be found the call fails\n            with a fatal error.\n\n            See the perlmod manpage for a list of standard modules\n            and pragmas.\n\n
utime=    utime LIST\n            Changes the access and modification times on each file\n            of a list of files. The first two elements of the list\n            must be the NUMERICAL access and modification times, in\n            that order. Returns the number of files successfully\n            changed. The inode modification time of each file is set\n            to the current time. This code has the same effect as\n            the "`touch'" command if the files already exist:\n                $now = time;\n                utime $now, $now, @ARGV;\n\n
values=    values HASH\n            Returns a list consisting of all the values of the named\n            hash. (In a scalar context, returns the number of\n            values.) The values are returned in an apparently random\n            order. The actual random order is subject to change in\n            future versions of perl, but it is guaranteed to be the\n            same order as either the `keys()' or `each()' function\n            would produce on the same (unmodified) hash.\n            way, because the returned list is just a copy. You need\n            to use a hash slice for that, since it's lvaluable in a\n            way that values() is not.\n\n                for (values %hash)      { s/foo/bar/g }   # FAILS!\n                for (@hash{keys %hash}) { s/foo/bar/g }   # ok\n\n            As a side effect, calling values() resets the HASH's\n            internal iterator. See also `keys()', `each()', and\n            `sort()'.\n\n
vec=    vec EXPR,OFFSET,BITS\n            Treats the string in EXPR as a vector of unsigned\n            integers, and returns the value of the bit field\n            specified by OFFSET. BITS specifies the number of bits\n            that are reserved for each entry in the bit vector. This\n            must be a power of two from 1 to 32. `vec()' may also be\n            assigned to, in which case parentheses are needed to\n            give the expression the correct precedence as in\n\n            Vectors created with `vec()' can also be manipulated\n            with the logical operators `|', `&', and `^', which will\n            assume a bit vector operation is desired when both\n            operands are strings. See the section on "Bitwise String\n            Operators" in the perlop manpage.\n\n            The following code will build up an ASCII string saying\n            `'PerlPerlPerl''. The comments show the string after\n            each step. Note that this code works in the same way on\n            big-endian or little-endian machines.\n\n                my $foo = '';\n                vec($foo,  0, 32) = 0x5065726C;     # 'Perl'\n                vec($foo,  2, 16) = 0x5065;         # 'PerlPe'\n                vec($foo,  3, 16) = 0x726C;         # 'PerlPerl'\n                vec($foo,  8,  8) = 0x50;           # 'PerlPerlP'\n                vec($foo,  9,  8) = 0x65;           # 'PerlPerlPe'\n                vec($foo, 20,  4) = 2;              # 'PerlPerlPe'   . "\\x02"\n                vec($foo, 21,  4) = 7;              # 'PerlPerlPer'\n                                                    # 'r' is "\\x72"\n                vec($foo, 45,  2) = 3;              # 'PerlPerlPer'  . "\\x0c"\n                vec($foo, 93,  1) = 1;              # 'PerlPerlPer'  . "\\x2c"\n                vec($foo, 94,  1) = 1;              # 'PerlPerlPerl'\n                                                    # 'l' is "\\x6c"\n\n            To transform a bit vector into a string or array of 0's\n            and 1's, use these:\n\n                $bits = unpack("b*", $vector);\n                @bits = split(//, unpack("b*", $vector));\n\n            If you know the exact length in bits, it can be used in\n            place of the `*'.\n\n
wantarray=    wantarray\n            Returns TRUE if the context of the currently executing\n            subroutine is looking for a list value. Returns FALSE if\n            the context is looking for a scalar. Returns the\n            undefined value if the context is looking for no value\n            (void context).\n                my @a = complex_calculation();\n                return wantarray ? @a : "@a";\n\n
warn=    warn LIST\n            Produces a message on STDERR just like `die()', but\n            doesn't exit or throw an exception.\n            (typically from a previous eval) that value is used\n            after appending `"\\t...caught"' to `$@'. This is useful\n            for staying almost, but not entirely similar to `die()'.\n\n            If `$@' is empty then the string `"Warning: Something's\n            wrong"' is used.\n\n            No message is printed if there is a `$SIG{__WARN__}'\n            handler installed. It is the handler's responsibility to\n            deal with the message as it sees fit (like, for\n            instance, converting it into a `die()'). Most handlers\n            must therefore make arrangements to actually display the\n            warnings that they are not prepared to deal with, by\n            calling `warn()' again in the handler. Note that this is\n            quite safe and will not produce an endless loop, since\n            `__WARN__' hooks are not called from inside one.\n\n            You will find this behavior is slightly different from\n            that of `$SIG{__DIE__}' handlers (which don't suppress\n            the error text, but can instead call `die()' again to\n            change it).\n\n            Using a `__WARN__' handler provides a powerful way to\n            silence all warnings (even the so-called mandatory\n            ones). An example:\n\n                # wipe out *all* compile-time warnings\n                BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }\n                my $foo = 10;\n                my $foo = 20;          # no warning about duplicate my $foo,\n                                       # but hey, you asked for it!\n                # no compile-time or run-time warnings before here\n                $DOWARN = 1;\n\n                # run-time warnings enabled after here\n                warn "\\$foo is alive and $foo!";     # does show up\n\n            See the perlvar manpage for details on setting `%SIG'\n            entries, and for more examples. See the Carp module for\n            other kinds of warnings using its carp() and cluck()\n            functions.\n\n
write=    write FILEHANDLE\n    write EXPR\n    write   Writes a formatted record (possibly multi-line) to the\n            specified FILEHANDLE, using the format associated with\n            that file. By default the format for a file is the one\n            having the same name as the filehandle, but the format\n            for the current output channel (see the `select()'\n            function) may be set explicitly by assigning the name of\n            the format to the `$~' variable.\n            there is insufficient room on the current page for the\n            formatted record, the page is advanced by writing a form\n            feed, a special top-of-page format is used to format the\n            new page header, and then the record is written. By\n            default the top-of-page format is the name of the\n            filehandle with "_TOP" appended, but it may be\n            dynamically set to the format of your choice by\n            assigning the name to the `$^' variable while the\n            filehandle is selected. The number of lines remaining on\n            the current page is in variable `$-', which can be set\n            to `0' to force a new page.\n\n            If FILEHANDLE is unspecified, output goes to the current\n            default output channel, which starts out as STDOUT but\n            may be changed by the `select()' operator. If the\n            FILEHANDLE is an EXPR, then the expression is evaluated\n            and the resulting string is used to look up the name of\n            the FILEHANDLE at run time. For more on formats, see the\n            perlform manpage.\n\n            Note that write is *NOT* the opposite of `read()'.\n            Unfortunately.\n\n
y=    y///    The transliteration operator. Same as `tr///'. See the\n            perlop manpage.
